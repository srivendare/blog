<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>JavaScript 继承 · XWARTZ</title><meta name="description" content="JavaScript 继承 - xwartz"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/blog/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_1472710214_6648843.css"><link rel="stylesheet" href="//raw.githack.com/xwartz/hexo-theme-nuna/next/source/style/main.css?v=1.0.3"></head><body class="pupa"><div class="loading-bar"></div><main><div class="post post"><article itemscope itemtype="http://schema.org/Article" class="hentry"><div itemprop="image" style="background-image: url(http://ww1.sinaimg.cn/large/65e4f1e6gw1f7ipx660akj21hc0xcn0m.jpg)" class="entry-cover"></div><div class="container"><div class="entry-header"><h1 class="entry-title">JavaScript 继承</h1><div class="entry-description"><p>关于 JavaScript 继承的回顾。</p></div><div class="entry-meta"><time itemprop="datePublished" datetime="Thursday, August 4th 2016, 9:30:20 am" class="updated">Aug 4, 2016</time><em class="post-count">3,820 words</em></div></div><div itemprop="articleBody" class="entry-content"><blockquote>
<p><code>JavaScript</code> 是一种基于原型的面向对象语言，而不是基于类的。<br>  正是由于这一根本的区别，其如何创建对象的层级结构以及对象的属性与属性值是如何继承的并不是那么清晰。</p>
</blockquote>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象就是一系列属性的集合，属性就是键值对 <code>key: value</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  <span class="attr">x</span>: <span class="number">10</span>,</div><div class="line">  <span class="attr">y</span>: <span class="number">20</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>JavaScript</code> 中的继承其实就是对象与对象之间层级结构关系的讨论。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>在 <code>JavaScript</code> 中，每个对象都有一个指向它的原型 <code>prototype</code> 对象的内部链接。<br>这个原型对象又有自己的原型，直到某个对象的原型为 <code>null</code> 为止。这种一级一级的链结构就称为原型链（prototype chain）。</p>
<p>对象原型指定可以使用 <code>__proto__</code> 属性。</p>
<p class='tip'><br>根据 ECMAScript 标准，someObject.[[Prototype]] 符号是用于指派 someObject 的原型。<br>这个等同于 JavaScript 的 <code>__proto__</code>  属性（现已弃用）。<br>从 ECMAScript 6 开始, [[Prototype]] <code>可以用 Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code> 访问器来访问。<br></p>

<p>也就是说，以下涉及到 <code>__proto__</code> 的方式，都可以使用 <code>Object.getPrototypeOf()</code> 来获取原型，或者使用 <code>Object.setPrototypeOf()</code> 来设置原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  <span class="attr">x</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">y</span>: <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = &#123;&#125;</div><div class="line"></div><div class="line">b.__proto__ = a <span class="comment">// 将对象的原型指向 a, 等同于 b = Object.setPrototypeOf(&#123;&#125;, a)</span></div><div class="line"></div><div class="line">b.x <span class="comment">// 1</span></div><div class="line">b.y <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>其实 <code>new</code> 关键字会做类似的操作，在构造函数下会做说明。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在 <code>JavaScript</code> 中构造函数就是一个函数，可以使用 <code>new</code> 操作符作用这个函数，实例化一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.y = y</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.x = <span class="number">1</span></div><div class="line"></div><div class="line">Foo.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实例化对象 b</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="number">2</span>)</div><div class="line"></div><div class="line">b.x <span class="comment">// 1</span></div><div class="line">b.y <span class="comment">// 2</span></div><div class="line"></div><div class="line">b.__proto__ === Foo.prototype <span class="comment">// true, 等同于 Object.setPrototypeOf(b) === Foo.prototype</span></div><div class="line"></div><div class="line"><span class="comment">// constructor 返回一个指向创建了该对象原型的函数引用</span></div><div class="line">b.constructor === Foo <span class="comment">// true</span></div><div class="line"></div><div class="line">Foo.prototype.constructor === Foo <span class="comment">// true</span></div><div class="line"></div><div class="line">b.fn === b.__proto__.fn <span class="comment">// true</span></div><div class="line"></div><div class="line">b.__proto__.fn === Foo.prototype.fn <span class="comment">// true</span></div></pre></td></tr></table></figure>
<img src="/blog/2016/08/javascript-inheritance/1.png" alt="1.png" title="">
<p>从以上结果可以推测，当执行 <code>new</code> 操作符时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><code>JavaScript</code> 实际上执行了以下操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>()</div><div class="line">b.__proto__ = Foo.prototype</div><div class="line">Foo.call(b, <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>知道了原理之后，我们就可以使用构造函数的方式来实现继承了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Bar 继承 Foo</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="comment">// 继承构造函数中的属性</span></div><div class="line">  Foo.call(<span class="keyword">this</span>, x)</div><div class="line">  <span class="comment">// 增加属性</span></div><div class="line">  <span class="keyword">this</span>.y = y</div><div class="line">&#125;</div><div class="line"><span class="comment">// 继承原型链上的属性</span></div><div class="line"><span class="comment">// 这里有个不优雅的地方是会在 Bar 原型连上产生一个 Foo 自身的属性 x undefined</span></div><div class="line">Bar.prototype = <span class="keyword">new</span> Foo()</div><div class="line"></div><div class="line"><span class="comment">// 如果 Bar.prototype = Foo.prototype, 除了构造函数 Bar 和 Foo 其实是一样的</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="number">1</span>)</div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Bar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line">bar.__proto__ === Bar.prototype <span class="comment">// true</span></div><div class="line">bar.__proto__.__proto__ === foo.__proto__ <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h5 id="总得来说，要实现继承分两步走："><a href="#总得来说，要实现继承分两步走：" class="headerlink" title="总得来说，要实现继承分两步走："></a>总得来说，要实现继承分两步走：</h5><ol>
<li>继承构造函数里的属性(父类自身的属性)</li>
<li>继承原型链上的属性</li>
</ol>
<h3 id="Object-create-实现继承"><a href="#Object-create-实现继承" class="headerlink" title="Object.create 实现继承"></a>Object.create 实现继承</h3><blockquote>
<p><code>Object.create()</code> 方法创建一个拥有指定原型和若干个指定属性的对象。</p>
</blockquote>
<p><em>这是一个 <code>ES5</code> 中的方法，IE &gt;= 9。</em></p>
<p>使用 <code>Object.create()</code> 来解决上面子类原型链上产生父类自身属性的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Bar 继承 Foo</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="comment">// 继承构造函数中的属性</span></div><div class="line">  Foo.call(<span class="keyword">this</span>, x)</div><div class="line">  <span class="comment">// 增加属性</span></div><div class="line">  <span class="keyword">this</span>.y = y</div><div class="line">&#125;</div><div class="line"><span class="comment">// 继承原型链上的属性</span></div><div class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype)</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="number">1</span>)</div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Bar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line">bar.__proto__ === Bar.prototype <span class="comment">// true</span></div><div class="line">bar.__proto__.__proto__ === foo.__proto__ <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="class-关键字"><a href="#class-关键字" class="headerlink" title="class 关键字"></a>class 关键字</h3><p>ES6 加入语法糖 <code>class</code>，实现继承就更加方便一些了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="comment">// 构造函数</span></div><div class="line">  <span class="keyword">constructor</span>(x) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 原型链上的方法</span></div><div class="line">  fn () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="comment">// 子类构造函数</span></div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">super</span>(x) <span class="comment">// 访问父对象上的构造函数</span></div><div class="line">    <span class="keyword">this</span>.y = y</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="number">1</span>)</div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Bar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line">bar.__proto__.__proto__ === foo.__proto__ <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><blockquote>
<p>某些面向对象语言支持多重继承。也就是说，对象可以从无关的多个父对象中继承属性和属性值。JavaScript 不支持多重继承。</p>
</blockquote>
<p>在 <code>JavaScript</code> 中，可以在构造器函数中调用多个其它的构造器函数。这一点造成了多重继承的假象。例如，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.y = y</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Baz</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  Foo.call(<span class="keyword">this</span>, x)</div><div class="line">  Bar.call(<span class="keyword">this</span>, y)</div><div class="line">&#125;</div><div class="line"></div><div class="line">Baz.prototype = <span class="keyword">new</span> Bar()</div><div class="line"></div><div class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> Baz(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// &#123;x: 1, y: 2&#125;</span></div></pre></td></tr></table></figure>
<p>以上看起来 baz 的属性 <code>{x: 1, y: 2}</code> 中包含了 <code>Foo</code> 和 <code>Bar</code> 的属性，但是更新 <code>Foo</code> 的原型链上的属性，并不会被继承下来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Foo.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>实例 baz 还是原来的样子，并没有 fn 属性。<br>当然你可以把 <code>Foo</code> 的原型链上的属性复制到 Baz 的 <code>prototype</code> 上，但之后 <code>Foo</code> 原型链上属性的更新并不会被继承。</p>
<p>造成这个的原因是: <code>JavaScript</code> 的继承是在运行时通过检索对象的原型链来实现的。因为对象只有一个原型与之关联，所以 <code>JavaScript</code> 无法动态地从多个原型链中继承。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>总得来说使用 <code>ES6</code> 来实现继承更加方便了，但是了解下原型链还是很有必要的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">Object.prototype.<strong>proto</strong></a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor">Object.prototype.constructor</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects">Working with objects</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model">Details of the object model</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">Inheritance and the prototype chain</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create()</a></p>
<p><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/">JavaScript. The core. (Dmitry A. Soshnikov ECMA-262 article series)</a></p></div><div class="entry-extra"><div class="entry-tags"><a href="/blog/tags/code/" class="tag">code</a></div></div></div></article></div></main><footer><div class="copyright container"><p>© Copyright 2015 - 2018 by <a href="http://github.com/xwartz">xwartz</a>.</p></div></footer><script async src="//cdn.bootcss.com/mathjax/2.7.0-beta.0/MathJax.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-69822347-1",'auto');
ga('set', 'appName',"XWARTZ");
ga('send','pageview');</script><script>(function () { var sid =500303098;cid =500303108;var hm = document.createElement('script');
hm.src = 'http://pingjs.qq.com/h5/stats.js';
hm.setAttribute('name', 'MTAH5'); hm.setAttribute('sid', sid); hm.setAttribute('cid', cid);
var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);
}())</script><script>var _vds = _vds || [];
window._vds = _vds;
(function(){
  ;_vds.push(['setAccountId',"90b580e047dd0007"  ]);
  (function() {
      var vds = document.createElement('script');
      vds.type='text/javascript';
      vds.async = true;
      vds.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'dn-growing.qbox.me/vds.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(vds, s);
  })();
})();</script><script async src="//raw.githack.com/Easyfood/pageAccelerator/master/dist/page-accelerator.min.js"></script><script async src="/blog/script/loading.js"></script><script async src="/blog/script/photo.js"></script></body></html>