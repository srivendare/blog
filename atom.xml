<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XWARTZ</title>
  
  <subtitle>To Be An Artist</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://github.com/xwartz/"/>
  <updated>2017-03-02T01:56:27.000Z</updated>
  <id>http://github.com/xwartz/</id>
  
  <author>
    <name>xwartz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Debugging React Native</title>
    <link href="http://github.com/xwartz/2017/02/debugging-react-native/"/>
    <id>http://github.com/xwartz/2017/02/debugging-react-native/</id>
    <published>2017-02-22T02:11:54.000Z</published>
    <updated>2017-03-02T01:56:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 React Native 的一点调试经验</p><a id="more"></a><p>React Native 无疑给移动端开发带来效率的提升，我们目前的产品中，iOS 和 Android 代码复用率应该在 80~90%(保守估计)。</p><p>虽然 React Native 提升了开发效率，但在 debug 时还是有很多不爽的地方。</p><p>一些基础的调试方法可以查看官方文档 <a href="https://facebook.github.io/react-native/docs/debugging.html" target="_blank" rel="external">Debugging</a>。</p><p><a href="https://facebook.github.io/react-native/blog/2016/03/24/introducing-hot-reloading.html" target="_blank" rel="external">Hot Reloading</a> 应该是我目前最喜欢 RN 的一个地方了吧，和 web 一致的开发体验。</p><p><a href="https://facebook.github.io/react-native/docs/debugging.html#chrome-developer-tools" target="_blank" rel="external">Debug JS Remotely</a> 也是比较基础的调试方式，可以在 Chrome DevTools 打断点调试。</p><p>不推荐使用 <code>react-native log-ios</code>，调试起来一点都不方便。直接 <code>console.log</code> 在 Chrome DevTools 调试会更方便一些。</p><p>但是 <code>console.log</code> 会使整个程序变卡顿，尤其在 Android 下，界面卡顿无比，所以不建议打印所有信息。</p><p>因此，以下的一些方法主要在于怎么减少在 console 打印信息，而又能方便的调试。</p><h3 id="使用-window-store"><a href="#使用-window-store" class="headerlink" title="使用 window.store"></a>使用 window.store</h3><p><code>console.log</code> 会极大地拖累 JavaScript 线程，所以并不推荐使用 <code>redux-logger</code>。</p><p>要获取 store 的信息，可以用如下方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (isDebuggingInChrome) &#123;</div><div class="line">  <span class="built_in">window</span>.store = store</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过 <code>store.getState()</code> 的方式打印查看 <code>reducer</code> 的状态。</p><p><img src="https://ww2.sinaimg.cn/large/006tKfTcly1fd7r3rky7dj30oc0hmdho.jpg" alt=""></p><h3 id="在-Chrome-中显示网络请求"><a href="#在-Chrome-中显示网络请求" class="headerlink" title="在 Chrome 中显示网络请求"></a>在 Chrome 中显示网络请求</h3><p>查看 RN 源码 <a href="https://github.com/facebook/react-native/blob/dba133a29194e300e9a2e9e6753f9d4e3a13c194/Libraries/Core/InitializeCore.js#L51">Libraries/Core/InitializeCore.js</a>，注释中写着：</p><blockquote><p>  /**</p><ul><li>Sets an object’s property. If a property with the same name exists, this will</li><li>replace it but maintain its descriptor configuration. By default, the property</li><li>will replaced with a lazy getter.<br>*</li><li>The original property value will be preserved as <code>original[PropertyName]</code> so</li><li>that, if necessary, it can be restored. For example, if you want to route</li><li>network requests through DevTools (to trace them):<br>*</li><li>global.XMLHttpRequest = global.originalXMLHttpRequest;<br>*</li><li>@see <a href="https://github.com/facebook/react-native/issues/934">https://github.com/facebook/react-native/issues/934</a><br>*/</li></ul></blockquote><p>原来的 <code>XMLHttpRequest</code> 被改写成了  <code>originalXMLHttpRequest</code>，</p><p>所以要在 Chrome 中显示 <code>network</code> 只需要替换 <code>XMLHttpRequest</code> 为 <code>originalXMLHttpRequest</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (__DEV__) &#123;</div><div class="line">  GLOBAL.XMLHttpRequest = GLOBAL.originalXMLHttpRequest || GLOBAL.XMLHttpRequest</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当然，这样有可能会产生 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a>, Chrome 会限制跨域请求。</p><p>这时要么后端配合一下去除限制，要么使用 <a href="https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi" target="_blank" rel="external">Allow-Control-Allow-Origin: *</a> 插件。</p><p>这样就可以愉快的调试网络请求了，而不用打印出来，毕竟打印实在是太卡了。</p><p><img src="https://ww3.sinaimg.cn/large/006tKfTcly1fd7rux58ayj31da0myq9y.jpg" alt=""></p><h3 id="react-native-debugger"><a href="#react-native-debugger" class="headerlink" title="react-native-debugger"></a>react-native-debugger</h3><p>无意中看到这个 repo <a href="https://github.com/jhen0409/react-native-debugger#react-native-debugger">react-native-debugger</a>，</p><p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fd894emd5jj30x90nhaf5.jpg" alt=""></p><p>使用了 electron，竟然还注入了 React Inspector / Redux DevTools，可以尝试使用。</p><p>不知道效果如何，倒是可以看看源码学习下。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>目前 UI 上的调试，并没有找到什么好的方案，所以只能等 RN 团队的推进了。</p><p>希望 RN 早点迎来 1.0.0 release。</p><p>有时间还是要多阅读 RN 源码才好。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://facebook.github.io/react-native/docs/performance" target="_blank" rel="external">doc performance</a><br><a href="https://facebook.github.io/react-native/docs/debugging" target="_blank" rel="external">doc debugging</a><br><a href="https://github.com/facebook/react-native">react-native</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 React Native 的一点调试经验&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
      <category term="react-native" scheme="http://github.com/xwartz/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>2016 in review</title>
    <link href="http://github.com/xwartz/2017/01/2016-in-review/"/>
    <id>http://github.com/xwartz/2017/01/2016-in-review/</id>
    <published>2017-01-07T15:36:49.000Z</published>
    <updated>2017-01-08T01:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>我的 2016 刚结束新开始。</p><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>年初的时候，离开了第一家公司，</p><p>当初实习时，上下班接近 3 小时还历历在目。</p><p>2 个月前离开第二家公司，还是要有点技术追求的。</p><p>离开一个熟悉的环境，每次都有新的认知。</p><p>变化才能有更多可能性，有趣的是，</p><p>在上家公司面基了在 github 上认识的人，</p><p>在现在的公司和原来公司的竞争对手成了同事。</p><p>如果我一直待在一个地方，就不会认识这么些人。</p><p>Interesting.</p><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgw1fbcr5a5a2uj315i0b8goa.jpg" alt=""></p><p>这是我有账号以来，github 上最活跃的一年。</p><blockquote><ul><li>写了不少博客文章 <a href="https://github.com/xwartz/blog">blog</a></li><li>写了 hexo theme <a href="https://github.com/xwartz/hexo-theme-nuna">nuna</a> / <a href="https://github.com/xwartz/hexo-theme-nuna">pupa</a></li><li>写了 douban.fm 客户端 <a href="https://github.com/xwartz/PupaFM">PupaFM</a></li><li>写了 Sublime text plugin <a href="https://github.com/xwartz/Auto-Spacing">Auto-Spacing</a></li><li>写了 github 的小脚本 <a href="https://github.com/xwartz/robot">robot</a></li><li>参与了不少开源项目，提了不少 pr 被 merge</li><li>新工作疯狂码代码中</li></ul></blockquote><h4 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h4><p><img src="https://ww2.sinaimg.cn/large/006tNbRwgw1fbijg97gorj30m80bit9a.jpg" alt=""></p><p>新公司入坑了 React Native，熟悉原生中，Android / iOS 有的搞。</p><p>React Native 一年发布了 100 多个版本，社区的活跃，让它渐渐稳定。</p><p>期待 v1.0.0 的到来。</p><h4 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h4><p>更多的编写脚本自动干一些重复的活。</p><p>花了更多时间写测试，Jest / Appium，搭建 Jenkins Ci。 </p><p>写更多的 Shell / Make 脚本，我受够了渣渣网络下的 node_modules 。</p><h4 id="Code-Styles"><a href="#Code-Styles" class="headerlink" title="Code Styles"></a>Code Styles</h4><p><a href="https://github.com/feross/standard">standard</a> 成为标配。</p><p>不再写分号，在团队和个人项目中都实践中。</p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>读了<a href="https://book.douban.com/people/samedie/collect" target="_blank" rel="external">几本书</a>，但是似乎也没记得多少…</p><p>希望能静下心读点书。</p><h4 id="出玩"><a href="#出玩" class="headerlink" title="出玩"></a>出玩</h4><p>前公司福利，去了一趟大理。</p><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgw1fbiivx13agj30yo0q0jvg.jpg" alt="大理"></p><p>从工作以来，还是很少出去玩的，希望今年能有机会出去走走。</p><h4 id="喵"><a href="#喵" class="headerlink" title="喵"></a>喵</h4><p>成为了一名铲屎官。</p><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgw1fbiijlcmbgj315t15t0zb.jpg" alt="Hello world"></p><p>卖卖萌，我很开心。</p><p>从此有 🐱 陪我看电影 码代码，hahahaha…</p><p>然而现实是，</p><p>咬人、抓人、不让睡觉…</p><p>她只会捣乱，最后只有互相伤害 😂。</p><h4 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h4><p>希望</p><p>不设限，有所获。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的 2016 刚结束新开始。&lt;/p&gt;
&lt;h4 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h4&gt;&lt;p&gt;年初的时候，离开了第一家公司，&lt;/p&gt;
&lt;p&gt;当初实习时，上下班接近 3 小时还历历在目。&lt;/
      
    
    </summary>
    
    
      <category term="life" scheme="http://github.com/xwartz/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Immutable.js 笔记</title>
    <link href="http://github.com/xwartz/2016/12/immutable-js/"/>
    <id>http://github.com/xwartz/2016/12/immutable-js/</id>
    <published>2016-12-27T15:46:37.000Z</published>
    <updated>2016-12-31T02:30:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Immutable.js 使用笔记。</p><a id="more"></a><p>所有涉及到的方法都可以在<a href="https://facebook.github.io/immutable-js/docs" target="_blank" rel="external">官方文档</a>查到，只是官方文档晦涩难懂。</p><p>查看转化后的 JavaScript 原型，打开 console 使用 <code>Immutable.toJS()</code> 或者查看 <code>_tail</code> 字段。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Immutable List 类似 JavaScript array。</p><h3 id="创建-List"><a href="#创建-List" class="headerlink" title="创建 List"></a>创建 List</h3><p><code>List()</code> 与 <code>List.of()</code> 的不同：</p><ul><li><code>List.of()</code> - 作用于 non-iterable 数据(如函数参数、JavaScript 对象、字符串)</li><li><code>List()</code> - 作用于 iterable 数据(数组、Immutable 对象(List, Map, Set…)、字符串中单个字符)</li></ul><p><strong>注意：JavaScript 中 string 是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Builtin_iterables" target="_blank" rel="external">iterable object</a>。</strong></p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> args = Immutable.List.of(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</div><div class="line"></div><div class="line"><span class="comment">// Output: </span></div><div class="line"><span class="built_in">Array</span> [</div><div class="line">  <span class="string">'a'</span>,</div><div class="line">  <span class="string">'b'</span>,</div><div class="line">  <span class="string">'c'</span></div><div class="line">]</div></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><code>List.of()</code> 会把对象转为 List 的一个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</div><div class="line"><span class="keyword">const</span> list = Immutable.List.of(obj)</div><div class="line"></div><div class="line"><span class="comment">// Output: </span></div><div class="line"><span class="built_in">Array</span> [</div><div class="line">  <span class="built_in">Object</span> &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>: <span class="number">2</span></div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> str = <span class="string">'abc'</span></div><div class="line"><span class="keyword">const</span> list = Immutable.List.of(str)</div><div class="line"></div><div class="line"><span class="comment">// Output: </span></div><div class="line"><span class="built_in">Array</span> [</div><div class="line">  <span class="string">'a,b,c'</span></div><div class="line">]</div></pre></td></tr></table></figure><p>因为 JavaScript 中 string 是 iterable 的，所以想把整个 string 当做一个整体的就使用 <code>List.of()</code>，<code>List()</code> 转化如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> str = <span class="string">'abc'</span></div><div class="line"><span class="keyword">const</span> list = Immutable.List(str)</div><div class="line"></div><div class="line"><span class="comment">// Output: </span></div><div class="line"><span class="built_in">Array</span> [</div><div class="line">  <span class="string">'a'</span>,</div><div class="line">  <span class="string">'b'</span>,</div><div class="line">  <span class="string">'c'</span></div><div class="line">]</div></pre></td></tr></table></figure><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>ES6 现有的 iterators 类型:</p><ul><li><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="external">String</a></li><li><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">Array</a></li><li><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="external">TypedArray</a></li><li><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="external">Map</a></li><li><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="external">Set</a></li></ul><p>当然也可以自行构建 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="external">iterable</a>。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="keyword">const</span> list = Immutable.List(num)</div><div class="line"></div><div class="line"><span class="comment">// Output: </span></div><div class="line"><span class="built_in">Array</span> [</div><div class="line">  <span class="number">1</span>,</div><div class="line">  <span class="number">2</span>,</div><div class="line">  <span class="number">3</span></div><div class="line">]</div></pre></td></tr></table></figure><h4 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> num = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]]</div><div class="line"><span class="keyword">const</span> list = Immutable.List(num)</div><div class="line"></div><div class="line">Immutable.List.isList(list.getIn([<span class="number">1</span>])) <span class="comment">// false</span></div></pre></td></tr></table></figure><p><code>Immutable.List</code> 只转化一层，而 <code>Immutable.fromJS</code> 支持嵌套转化，将每一层数据都转为 Immutable。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> num = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]]</div><div class="line"><span class="keyword">const</span> list = Immutable.fromJS(num)</div><div class="line"></div><div class="line">Immutable.List.isList(list.getIn([<span class="number">1</span>])) <span class="comment">// true</span></div></pre></td></tr></table></figure><h3 id="Immutable-js-类型"><a href="#Immutable-js-类型" class="headerlink" title="Immutable.js 类型"></a>Immutable.js 类型</h3><p>Immutable 中 iterable 的类型有：<code>List</code>, <code>Map</code>, <code>OrderedMap</code>, <code>Set</code>, <code>OrderedSet</code>, <code>Stack</code>, <code>Record</code>。</p><h4 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h4><p><code>List()</code> 一个 <code>List</code> 对象和原来相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> list = Immutable.List([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="keyword">const</span> newList = Immutable.List(list)</div><div class="line"></div><div class="line">list.equals(newList) <span class="comment">// true</span></div></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>List()</code> 会将 <code>Map</code> key/value 转为一个数组元组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = Immutable.Map(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;)</div><div class="line"><span class="keyword">const</span> list = Immutable.List(map)</div><div class="line"></div><div class="line"><span class="comment">// Output: </span></div><div class="line"><span class="built_in">Array</span> [</div><div class="line">  [<span class="string">'a'</span>, <span class="number">1</span>,],</div><div class="line">  [<span class="string">'b'</span>, <span class="number">2</span>]</div><div class="line">]</div></pre></td></tr></table></figure><h3 id="get-set"><a href="#get-set" class="headerlink" title="get() / set()"></a>get() / set()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> list = Immutable.List([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">list.get(<span class="number">0</span>) <span class="comment">// 1</span></div><div class="line">list.get(<span class="number">-3</span>) <span class="comment">// 1 反向</span></div></pre></td></tr></table></figure><p><code>getIn</code> 访问嵌套数组的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> list = Immutable.fromJS([<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]])</div><div class="line">list.getIn([<span class="number">1</span>, <span class="number">0</span>]) <span class="comment">// 2</span></div></pre></td></tr></table></figure><p><code>set</code> 与 <code>setIn</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> list = Immutable.List([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">list.set(<span class="number">0</span>, <span class="string">'a'</span>) <span class="comment">// ['a', 2, 3]</span></div><div class="line">list.set(<span class="number">4</span>, <span class="string">'a'</span>) <span class="comment">// [1, 2, 3, undefined, 'a']</span></div><div class="line">list.set(<span class="number">-3</span>, <span class="string">'b'</span>) <span class="comment">// ['b', 2, 3]</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> list = Immutable.fromJS([<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]])</div><div class="line">list.setIn([<span class="number">1</span>, <span class="number">0</span>], <span class="string">'a'</span>) <span class="comment">// [1, ['a', 3]]</span></div></pre></td></tr></table></figure><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p><code>merge()</code> 是根据索引值的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> list1 = Immutable.List([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="keyword">const</span> list2 = Immutable.List([<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line"></div><div class="line">list1.merge(list2) <span class="comment">// ['a', 'b', 3]</span></div></pre></td></tr></table></figure><p><code>mergeWith()</code> 提供解决冲突的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> list1 = Immutable.List([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="keyword">const</span> list1 = Immutable.fromJS([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">list.mergeWith(<span class="function">(<span class="params">prev, next, index</span>) =&gt;</span> prev === <span class="number">1</span> ? prev : next, list1) <span class="comment">// [1, 'b', 'c']</span></div></pre></td></tr></table></figure><p><code>mergeDeep()</code> 作用嵌套数组每层</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> list = Immutable.fromJS([<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>])</div><div class="line"><span class="keyword">const</span> list1 = Immutable.fromJS([<span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>]])</div><div class="line">list.mergeDeep(list1) <span class="comment">// ['a', ['b', 'c'], 4]</span></div></pre></td></tr></table></figure><p><code>mergeDeepWith()</code> 作用嵌套数组每层</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> list = Immutable.fromJS([<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>])</div><div class="line"><span class="keyword">const</span> list1 = Immutable.fromJS([<span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>]])</div><div class="line">list.mergeDeepWith(<span class="function">(<span class="params">prev, next, index</span>) =&gt;</span> prev === <span class="number">1</span> ? prev : next, list1) <span class="comment">// [1, ['b', 'c'], 4]</span></div></pre></td></tr></table></figure><h2 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h2><h3 id="创建-Map"><a href="#创建-Map" class="headerlink" title="创建 Map"></a>创建 Map</h3><h4 id="Map-of-作用于函数参数"><a href="#Map-of-作用于函数参数" class="headerlink" title="Map.of() 作用于函数参数"></a><code>Map.of()</code> 作用于函数参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = Immutable.Map.of(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>) <span class="comment">// &#123; a: 'b', c: 'd' &#125;</span></div></pre></td></tr></table></figure><h4 id="Map-2"><a href="#Map-2" class="headerlink" title="Map()"></a><code>Map()</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map1 = Immutable.Map([[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'c'</span>, <span class="string">'d'</span>]]) <span class="comment">// &#123; a: 'b', c: 'd' &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> map2 = Immutable.Map(&#123; <span class="attr">a</span>: <span class="string">'b'</span>, <span class="attr">c</span>: <span class="string">'d'</span> &#125;) <span class="comment">// &#123; a: 'b', c: 'd' &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> map3 = Immutable.Map(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span> &#125; &#125;) <span class="comment">// &#123; a: &#123; b: 'c' &#125; &#125;</span></div><div class="line">Immutable.Map.isMap(map3.get(<span class="string">'a'</span>)) <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> map4 = Immutable.fromJS(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span> &#125; &#125;) <span class="comment">// &#123; a: &#123; b: 'c' &#125; &#125;</span></div><div class="line">Immutable.Map.isMap(map4.get(<span class="string">'a'</span>)) <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> map5 = Immutable.Map(Immutable.List([[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'c'</span>, <span class="string">'d'</span>]])) <span class="comment">// &#123; a: 'b', c: 'd' &#125;</span></div></pre></td></tr></table></figure><h3 id="get-set-1"><a href="#get-set-1" class="headerlink" title="get() / set()"></a>get() / set()</h3><p><code>get</code> / <code>getIn</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map2 = Immutable.Map(&#123; <span class="attr">a</span>: <span class="string">'b'</span>, <span class="attr">c</span>: <span class="string">'d'</span> &#125;) <span class="comment">// &#123; a: 'b', c: 'd' &#125;</span></div><div class="line">map2.get(<span class="string">'a'</span>) <span class="comment">// 'b'</span></div><div class="line"></div><div class="line"><span class="comment">// get 的第二个参数，可以作为备选项，当没有获取到的时候，返回该值</span></div><div class="line">map2.get(<span class="string">'e'</span>, <span class="number">1</span>) <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> map4 = Immutable.fromJS(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span> &#125; &#125;) <span class="comment">// &#123; a: &#123; b: 'c' &#125; &#125;</span></div><div class="line">map4.getIn([<span class="string">'a'</span>, <span class="string">'b'</span>]) <span class="comment">// 'c'</span></div></pre></td></tr></table></figure><p><code>set</code> / <code>setIn</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map2 = Immutable.Map(&#123; <span class="attr">a</span>: <span class="string">'b'</span>, <span class="attr">c</span>: <span class="string">'d'</span> &#125;) <span class="comment">// &#123; a: 'b', c: 'd' &#125;</span></div><div class="line">map2.set(<span class="string">'e'</span>, <span class="string">'f'</span>) <span class="comment">// &#123; a: 'b', c: 'd', e: 'f' &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> map4 = Immutable.fromJS(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span> &#125; &#125;) <span class="comment">// &#123; a: &#123; b: 'c' &#125; &#125;</span></div><div class="line">map4.setIn([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'e'</span>) <span class="comment">// &#123; a: &#123; b: 'e' &#125; &#125;</span></div></pre></td></tr></table></figure><h4 id="merge-1"><a href="#merge-1" class="headerlink" title="merge"></a>merge</h4><p><code>merge()</code>、<code>mergeWith()</code>、 <code>mergeDeep()</code>、<code>mergeDeepWith()</code> 与 <code>List</code> 类似。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><code>Immutable.js</code> 文档中提供的方法还有很多，可以自己查看。</p><p>更复杂的操作，推荐阅读这篇文章 <a href="http://untangled.io/advanced-immutable-js-recipes-how-to-use-immutable-js-in-the-real-world/" target="_blank" rel="external">Advanced Immutable.js Recipes: How to use Immutable.js in the real world</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://untangled.io/immutable-js-an-introduction-with-examples-written-for-humans" target="_blank" rel="external">Immutable.js: An Introduction with examples written for humans</a><br><a href="https://facebook.github.io/immutable-js/docs" target="_blank" rel="external">Immutable.js docs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Immutable.js 使用笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
      <category term="Immutable.js" scheme="http://github.com/xwartz/tags/Immutable-js/"/>
    
  </entry>
  
  <entry>
    <title>为 React Native 应用写测试 II</title>
    <link href="http://github.com/xwartz/2016/12/testing-a-react-native-app-II/"/>
    <id>http://github.com/xwartz/2016/12/testing-a-react-native-app-II/</id>
    <published>2016-12-18T12:58:41.000Z</published>
    <updated>2017-02-16T15:57:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Component 测试</p><a id="more"></a><p>这是 <a href="/blog/tags/react-native">&lt;为 React Native 应用写测试&gt;</a> 的系列文章的第二篇，上一篇请看<a href="/blog/2016/11/testing-a-react-native-app">为 React Native 应用写测试 I</a>。</p><p>这篇主要会集中在 <code>Component</code> 层的单元测试编写。</p><p>注意：<em>以下涉及到的 React Native 版本为 0.36，官方版本推进很快，最新可能出现偏差。</em></p><p>待…</p><p>update: 2017-02-16, 23:54</p><p>去年年底一段时间确实太忙了，导致最后都没有时间写 Component 的测试，所以这篇文章要夭折了。</p><p>推荐去看 redux 的文档 <a href="https://github.com/reactjs/redux/blob/master/docs/recipes/WritingTests.md#components">Writing Tests</a>，以及文末的参考链接。</p><p>Happy Coding.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://facebook.github.io/jest/docs/tutorial-react-native" target="_blank" rel="external">https://facebook.github.io/jest/docs/tutorial-react-native</a><br><a href="https://github.com/reactjs/redux/blob/master/docs/recipes/WritingTests.md">https://github.com/reactjs/redux/blob/master/docs/recipes/WritingTests.md</a><br><a href="https://blog.callstack.io/unit-testing-react-native-with-the-new-jest-i-snapshots-come-into-play-68ba19b1b9fe#.xreydjkil" target="_blank" rel="external">Testing React Native with the <em>new</em> Jest — Part I</a><br><a href="https://blog.callstack.io/unit-testing-react-native-with-the-new-jest-ii-redux-snapshots-for-your-actions-and-reducers-8559f6f8050b#.gk3s28gar" target="_blank" rel="external">Testing React Native with the <em>new</em> Jest — Part II</a><br><a href="https://www.smashingmagazine.com/2016/08/test-automation-frameworks-for-react-native-apps/" target="_blank" rel="external">Diverse Test-Automation Frameworks For React Native Apps</a><br><a href="https://github.com/admc/wd">https://github.com/admc/wd</a><br><a href="https://github.com/appium/appium">https://github.com/appium/appium</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Component 测试&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
      <category term="react-native" scheme="http://github.com/xwartz/tags/react-native/"/>
    
      <category term="testing" scheme="http://github.com/xwartz/tags/testing/"/>
    
  </entry>
  
  <entry>
    <title>为 React Native 应用写测试 I</title>
    <link href="http://github.com/xwartz/2016/11/testing-a-react-native-app/"/>
    <id>http://github.com/xwartz/2016/11/testing-a-react-native-app/</id>
    <published>2016-11-18T12:58:41.000Z</published>
    <updated>2016-12-31T02:31:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>这会是一系列的文章，来介绍如何为 React Native App 写测试(包括 Unit Testing 和 Functional Testing)以及遇到的一些坑。</p><a id="more"></a><p>使用 React Native 开发有一些日子了，最近在补一些单元测试，赶发布留下的技术债…</p><p>这是 <a href="/blog/tags/react-native">&lt;为 React Native 应用写测试&gt;</a> 的系列文章的第一篇，希望能保持更新吧。</p><p>这篇主要会集中在 <code>Action</code> 和 <code>Reducer</code> 层的单元测试编写。</p><p>注意：<em>以下涉及到的 React Native 版本为 0.36，官方版本推进很快，最新可能出现偏差。</em></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>我们选用了 <a href="https://facebook.github.io/jest/" target="_blank" rel="external"><code>Jest</code></a> 来编写，似乎也没有其他什么可选择的了，毕竟都是 FB 家的，而且官方推荐，值得信赖。</p><p>基本的配置看<a href="https://facebook.github.io/jest/docs/tutorial-react-native" target="_blank" rel="external">官方文档</a>即可。</p><p>这里有点需要注意的地方，如果你在代码中使用了 <code>@providesModule</code>, 那么在 <code>package.json</code> 文件中需要以下配置:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">"jest": &#123;</div><div class="line">    "preset": "jest-react-native",</div><div class="line">    "haste": &#123;</div><div class="line">      "defaultPlatform": "ios",</div><div class="line">      "platforms": [</div><div class="line">        "android",</div><div class="line">        "ios"</div><div class="line">      ],</div><div class="line">      "providesModuleNodeModules": [</div><div class="line">        "react",</div><div class="line">        "react-native"</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;,</div></pre></td></tr></table></figure><h3 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h3><p>在为 React Native 写测试代码中最麻烦的事，就是要不停的 <code>mock</code>。</p><p>这里的 <code>mock</code> 涉及到两方面：普通的数据 mock 和 mock module。</p><p>数据 mock 很好理解，比如 A 函数 <code>const A = (a) =&gt;  a + 1</code>，写测试时，只需要 mock 一下 a 即可。</p><p><code>mock module</code> 是什么呢？</p><p>因为写 RN 项目时，会引入一些第三方组件，而那些组件可能涉及到了 <code>native</code> 层代码，<code>Jest</code> 环境并不能执行该代码，所以只能通过 mock 的方式。</p><p>例如，项目中使用了 <code>jpush-react-native</code>，可以如下方式 mock:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">jest.mock(<span class="string">'jpush-react-native'</span>, () =&gt; (&#123;</div><div class="line">  <span class="attr">getDeviceLocale</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'zh-CN'</span>,</div><div class="line">  <span class="attr">getUniqueID</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'deviceToken'</span>,</div><div class="line">  <span class="attr">getReadableVersion</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'1.0'</span>,</div><div class="line">  <span class="attr">getSystemVersion</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'10.0.0'</span>,</div><div class="line">  ...</div><div class="line">&#125;))</div></pre></td></tr></table></figure><p>总的来说，mock 其实也还算挺方便的，具体可以参考<a href="https://facebook.github.io/jest/docs/tutorial-react-native#mock-native-modules-using-jestmock" target="_blank" rel="external">文档</a>。</p><p>此外，涉及到网络请求的也需要 mock 一下，这里推荐 <a href="https://github.com/node-nock/nock">nock</a>。</p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>为了方便管理状态，项目中引入了 <a href="https://github.com/reactjs/redux"><code>Redux</code></a>，需要对此相关做单元测试。</p><h4 id="Action-Creators"><a href="#Action-Creators" class="headerlink" title="Action Creators"></a>Action Creators</h4><p>同步 <code>Action</code> 的测试非常简单，因为就是纯函数测试，直接拿<a href="https://github.com/reactjs/redux/blob/master/docs/recipes/WritingTests.md#action-creators">官方例子</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>,</div><div class="line">    text</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试编写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'../../actions/TodoActions'</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../../constants/ActionTypes'</span></div><div class="line"></div><div class="line">describe(<span class="string">'actions'</span>, () =&gt; &#123;</div><div class="line">  it(<span class="string">'should create an action to add a todo'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> text = <span class="string">'Finish docs'</span></div><div class="line">    <span class="keyword">const</span> expectedAction = &#123;</div><div class="line">      <span class="attr">type</span>: types.ADD_TODO,</div><div class="line">      text</div><div class="line">    &#125;</div><div class="line">    expect(actions.addTodo(text)).toEqual(expectedAction)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h4 id="Async-Action-Creators"><a href="#Async-Action-Creators" class="headerlink" title="Async Action Creators"></a>Async Action Creators</h4><p>异步 action 通常会使用 <a href="https://github.com/gaearon/redux-thunk">redux-thunk</a> 或者其他一些 <code>middleware</code>，所以需要 mock 一下 store，推荐 <a href="https://github.com/arnaudbenard/redux-mock-store">redux-mock-store</a>。</p><p>另外，对于网络请求，你可能需要使用 <a href="https://github.com/node-nock/nock">nock</a> 来 mock 各种网络状态。</p><p>除此之外，在 RN 中，<code>fetch</code> 使用的是 <a href="https://github.com/github/fetch">whatwg-fetch</a>，并且 <code>XMLHttpRequest</code> 是在<a href="https://github.com/facebook/react-native/blob/master/Libraries/Network/XMLHttpRequest.js">底层</a> 自己封装的。</p><p>在 <code>Jest</code> 中无法使用，<code>Jest</code> 执行环境是 <code>Nodejs</code>，所以还需要 <code>mock</code> 一下。</p><p><code>__mocks__/fetch.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @providesModule __mocks__/fetch</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">import</span> nodeFetch <span class="keyword">from</span> <span class="string">'node-fetch'</span></div><div class="line"></div><div class="line"><span class="comment">// Mocking the global.fetch included in React Native</span></div><div class="line">global.fetch = nodeFetch</div></pre></td></tr></table></figure><p><code>__mocks__/xhr.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @providesModule __mocks__/xhr</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">import</span> xmlhttprequest <span class="keyword">from</span> <span class="string">'xmlhttprequest'</span></div><div class="line">jest.mock(<span class="string">'XMLHttpRequest'</span>, () =&gt; xmlhttprequest.XMLHttpRequest)</div></pre></td></tr></table></figure><p>注意：这里使用 <code>jest.mock</code> 是因为在 RN <a href="https://github.com/facebook/react-native/blob/master/Libraries/Network/XMLHttpRequest.js#L9">XMLHttpRequest.js</a> 中注册了 <code>@providesModule XMLHttpRequest</code>，然后各种 <code>import XMLHttpRequest from XMLHttpRequest</code> 引入使用，而 fetch 是当做全局变量使用的。</p><p>所以 <code>mock store</code> 可能是这样子的：</p><p><code>redux-mock-store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @providesModule __mocks__/redux-mock-store</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="built_in">require</span>(<span class="string">'__mocks__/fetch'</span>)</div><div class="line"><span class="keyword">import</span> configureMockStore <span class="keyword">from</span> <span class="string">'redux-mock-store'</span></div><div class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></div><div class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'store/reducers'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> middlewares = [thunk]</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> initStore = configureMockStore(middlewares)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> initStore(reducers(&#123;&#125;, &#123; <span class="attr">type</span>: <span class="string">'__mocks__'</span> &#125;))</div></pre></td></tr></table></figure><p>接下来，我们就可以按照 <code>Redux</code> 官方文档来写<a href="https://github.com/reactjs/redux/blob/master/docs/recipes/WritingTests.md#async-action-creators">异步 action 的测试</a>了。</p><h4 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a>Reducers</h4><p>将 <code>Action</code> 和 <code>Reducer</code> 独立出来写单元测试之后，<code>Reducer</code> 的测试就变得很简单了，直接按照<a href="https://github.com/reactjs/redux/blob/master/docs/recipes/WritingTests.md#reducers">官方例子</a>来写就 OK 了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://facebook.github.io/jest/docs/tutorial-react-native" target="_blank" rel="external">https://facebook.github.io/jest/docs/tutorial-react-native</a><br><a href="https://github.com/reactjs/redux/blob/master/docs/recipes/WritingTests.md">https://github.com/reactjs/redux/blob/master/docs/recipes/WritingTests.md</a><br><a href="https://github.com/gaearon/redux-thunk">https://github.com/gaearon/redux-thunk</a><br><a href="https://github.com/arnaudbenard/redux-mock-store">https://github.com/arnaudbenard/redux-mock-store</a><br><a href="https://github.com/node-nock/nock">https://github.com/node-nock/nock</a><br><a href="https://github.com/bitinn/node-fetch">https://github.com/bitinn/node-fetch</a><br><a href="https://github.com/driverdan/node-XMLHttpRequest">https://github.com/driverdan/node-XMLHttpRequest</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这会是一系列的文章，来介绍如何为 React Native App 写测试(包括 Unit Testing 和 Functional Testing)以及遇到的一些坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
      <category term="react-native" scheme="http://github.com/xwartz/tags/react-native/"/>
    
      <category term="testing" scheme="http://github.com/xwartz/tags/testing/"/>
    
  </entry>
  
  <entry>
    <title>在 Mac 中安装 CocoaPods</title>
    <link href="http://github.com/xwartz/2016/10/install-cocoapod-on-mac/"/>
    <id>http://github.com/xwartz/2016/10/install-cocoapod-on-mac/</id>
    <published>2016-10-14T15:45:00.000Z</published>
    <updated>2016-11-18T12:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>CocoaPods 为 iOS 程序提供依赖管理的工具，类似 Node.js 的 npm 。</p><a id="more"></a><p>最近要开始搞 <a href="https://github.com/facebook/react-native">react-native</a>，安装 <a href="https://github.com/CocoaPods/CocoaPods">CocoaPods</a> 时，遇到点麻烦，所以记录一下。</p><p>执行 <code>sudo gem install cocoapods</code> 命令时，报了如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ERROR: Error installing cocoapods: </div><div class="line">activesupport requires Ruby version &gt;= 2.2.2.</div></pre></td></tr></table></figure><p>ruby 版本太低了，查看当前 <code>ruby -v</code> 版本： <code>ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin15]</code>。</p><h3 id="升级-ruby-版本"><a href="#升级-ruby-版本" class="headerlink" title="升级 ruby 版本"></a>升级 ruby 版本</h3><p>安装 rvm:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -L get.rvm.io | bash -s stable</div><div class="line">source ~/.rvm/scripts/rvm</div></pre></td></tr></table></figure><p>安装 ruby 版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rvm list known</div><div class="line">rvm install ruby-2.3.0</div></pre></td></tr></table></figure><p>继续报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Error running ‘requirements_osx_brew_update_system ruby-2.2.2’, </div><div class="line">showing last 15 lines of /Users/jolie/.rvm/log/1471244386_ruby-2.2.2/update_system.log </div><div class="line">https://github.com/Homebrew/homebrew/wiki/Common-Issues </div><div class="line">and make sure brew update works before continuing.’</div></pre></td></tr></table></figure><p>ok，<code>homebrew</code> 需要升级，我先卸载了，反正会再次被安装的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</div></pre></td></tr></table></figure><p>使用 ruby 2.3.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 查看已安装版本</div><div class="line">rvm list</div><div class="line"># 删除已安装版本</div><div class="line">rvm remove 2.0.0</div><div class="line"># 设置默认版本</div><div class="line">rvm install ruby-2.3.0</div><div class="line">rvm use 2.3.0 --default</div></pre></td></tr></table></figure><h3 id="安装-CocoaPods"><a href="#安装-CocoaPods" class="headerlink" title="安装 CocoaPods"></a>安装 CocoaPods</h3><p>为了加速安装速度，更换 gem 源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 查看源</div><div class="line">gem sources</div><div class="line"># 删除已有的源</div><div class="line">gem sources -r http://rubygems.org/</div><div class="line"># 更换为 ruby-china 的源</div><div class="line">gem sources -a https://gems.ruby-china.org/</div></pre></td></tr></table></figure><p>安装 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install cocoapods</div></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/" target="_blank" rel="external">用CocoaPods做iOS程序的依赖管理</a><br><a href="http://blog.csdn.net/fairytale_1/article/details/51850734" target="_blank" rel="external">关于安装cocoapods遇到的一些坑（ERROR: Error installing cocoapods: activesupport requires Ruby version &gt;= 2.2）</a><br><a href="http://www.jianshu.com/p/32d9cfb91471" target="_blank" rel="external">iOS CocoaPods 安装笔记</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CocoaPods 为 iOS 程序提供依赖管理的工具，类似 Node.js 的 npm 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>又折腾博客了</title>
    <link href="http://github.com/xwartz/2016/09/reduce-blog-load-time/"/>
    <id>http://github.com/xwartz/2016/09/reduce-blog-load-time/</id>
    <published>2016-09-29T13:33:28.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>我真的是不折腾不会死星人。</p><a id="more"></a><p>这次一时兴起又买了个域名，<code>xwartz.xyz</code>。每次重新折腾博客，总是换个域名，也好，不用看到以前写的东东。</p><p>当然，博客还是托管在 github pages，访问速度也就只能依靠 github 了。</p><p>不过也是要做点优化的，顺便记录一下，给其他托管在 github pages 的人一些参考吧。</p><h3 id="使用图床"><a href="#使用图床" class="headerlink" title="使用图床"></a>使用图床</h3><p>首先想到的优化点就是图片了，毕竟我的博客都是图片，不做点优化，等加载完花都谢了。</p><p>在做图片优化的时候，顺便打开了下我之前写的个人主页 <a href="http://xwartz.github.com，" target="_blank" rel="external">http://xwartz.github.com，</a><br>对，又是放在 github pages 上，唉，真是太穷了。</p><p>尼玛，打开真的是巨慢啊，然后看了一下，我去，放了一张 <code>2048 * 1024</code> 的背景图，<br>而且是被 webpack 打包到 react 代码中的，直接整个阻塞掉了。</p><p>对于之前那么多老外打开我的主页，只能说是真爱啊。</p><hr><p>开始着手优化图片加载，嗯，得找个图床，重点是要免费！</p><p>嗯，就是微博了，主要也就是这个上传接口 <a href="http://picupload.service.weibo.com/interface/。" target="_blank" rel="external">http://picupload.service.weibo.com/interface/。</a></p><p>先别撸起袖子就开始传，这种费力的活肯定有人造好轮子了，so，搜索了下就找到几个 chrome 插件:</p><p><a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf?hl=zh-CN" target="_blank" rel="external">新浪微博图床</a></p><p><a href="https://chrome.google.com/webstore/detail/%E5%9B%B4%E8%84%96%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%9B%BE%E5%BA%8A/pngmcllbdfgmhdgnnpfaciaolgbjplhe?hl=zh-CN" target="_blank" rel="external">围脖是个好图床</a></p><p><a href="https://github.com/Suxiaogang/WeiboPicBed">WeiboPicBed</a></p><p>试用了下，感觉也不是很方便，所以这里推荐下前同事写的 Mac 版 <a href="https://github.com/toolinbox/iPic">iPic</a>，非常棒的一个软件。</p><p>我就是用 iPic 把博客上的图片全都上传到了新浪微博，速度瞬间提升 N 倍(当然，是我以前没有做优化的原因)。</p><h3 id="github-资源使用-CDN"><a href="#github-资源使用-CDN" class="headerlink" title="github 资源使用 CDN"></a>github 资源使用 CDN</h3><p>其实托管在 github 上的博客，真的没有太多优化的点了，只能再从 js/css 静态资源上入手了。</p><p>我自己写了个博客主题 <a href="https://github.com/xwartz/hexo-theme-nuna">hexo-theme-nuna</a>，然后就想着把 github 上的资源托管到 CDN 上，</p><p>当然又准备找免费的 CDN 服务了，嗯，又被我找到了。。。</p><p><a href="https://rawgit.com/" target="_blank" rel="external">https://rawgit.com/</a></p><p><a href="https://raw.githack.com/" target="_blank" rel="external">https://raw.githack.com/</a></p><p><a href="https://gitcdn.xyz/" target="_blank" rel="external">https://gitcdn.xyz/</a></p><p>以上三个都可以托管 github 资源，区别的话看这里描述 <a href="https://github.com/schme16/gitcdn.xyz#how-is-this-different-from-rawgitcom-and-githackcom">How is this Different from RawGit.com and githack.com</a>。</p><p>gitcdn 是每次会取最新一个 commit 的资源，大概两小时刷新一次资源，其他两个如果是生产环境的话，一年才刷新。。。</p><h3 id="使用-pjax"><a href="#使用-pjax" class="headerlink" title="使用 pjax"></a>使用 pjax</h3><p>做了以上两件事，我的博客访问速度已经算比较快的了，但是作为一个静态博客其实还是可以做些优化的。</p><p>为了省去博客的 <code>reload</code>，使用了 <a href="https://github.com/Easyfood/pageAccelerator">pageAccelerator</a> 这个库。</p><p>原理也就是 <code>pjax</code>，在第一次加载之后，所有本站的链接点击，都会发起一个 <code>ajax</code> 请求，<br>然后将 <code>head</code> 做一个 <code>merge</code>，<code>body</code> 直接替换。</p><p>使用 <code>pushState</code> 更新浏览器访问记录，监听 <code>popstate</code> 事件，做前进/后退的活。</p><p>也没有特意做什么兼容，所以博客的浏览器支持 <code>IE10+</code> ，还有主题用了 <code>flex</code>，<br>本就没有想要兼容老的浏览器，毕竟也没什么人访问我的博客。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>通过以上几点的优化，博客的访问速度还算不错，当第一次打开博客之后，访问其他页面，基本上就是秒开了，体验非常棒。</p><p>可能后续还会做点优化，比如把国内的托管到 coding.net，海外的才指向 github 。</p><p>最后，放个福利 <a href="https://itunes.apple.com/us/app/automute-preventing-awkward/id1118136179?mt=12" target="_blank" rel="external">AutoMute</a>，上班时间喜欢戴耳机的朋友应该会喜欢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我真的是不折腾不会死星人。&lt;/p&gt;
    
    </summary>
    
    
      <category term="blog" scheme="http://github.com/xwartz/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>CasperJS</title>
    <link href="http://github.com/xwartz/2016/09/casperjs/"/>
    <id>http://github.com/xwartz/2016/09/casperjs/</id>
    <published>2016-09-20T03:45:27.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>这不是一篇介绍使用 CasperJS 进行单元测试的文章。</p><a id="more"></a><p>这是一篇使用 CasperJS 的一些经验记录，后续有遇到坑，或者什么使用心得就继续更新到这里了。</p><hr><p>写过前端单元测试的朋友，应该都知道 PhantomJS，我之前也写过几篇<a href="http://xwartz.github.io/pupa/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" target="_blank" rel="external">单元测试</a>相关的，也有用到。</p><blockquote><p>PhantomJS 是一个基于 WebKit 的服务器端 JavaScript API, 无需浏览器的支持即可实现对 Web 的支持，<br>且原生支持各种 Web 标准，如 DOM 处理、JavaScript、CSS 选择器、JSON、Canvas 和可缩放矢量图形 SVG。</p></blockquote><p>PhantomJS 形成的一些不错的开源生态圈内容, 相关项目：</p><ul><li>CasperJS：一个开源的导航脚本处理和高级测试工具</li><li>Poltergeist ：测试工具Capybara的测试驱动</li><li>Guard::Jasmine：能够基于Rails实现自动化测试Jasmine的Specs</li><li>GhostDriver：远程 WebDriver 有线协议的开源实现</li><li>PhantomRobot：PhantomJS机器人测试框架</li><li>Mocha-PhantomJS：JavaScript测试框架Mocha的客户端</li></ul><p>一个完整、活跃的生态圈是选择一个框架的重要参考，所以这也是相比 Vuejs 我更看好 Reactjs 的原因，跑偏了…😂</p><p>CasperJS 是一个用 JavaScript 编写的, 基于 PhantomJS 的导航脚本和测试工具,<br>它简化了定义一个完成的导航操作所需的步骤, 还提供了很有用的函数封装, 方法, 和语法糖, 它可以完成下面这些常见任务:</p><blockquote><ul><li>定义 &amp; 排序浏览器导航步骤</li><li>填充 &amp; 提交表单</li><li>点击 &amp; 跟踪链接</li><li>捕获网页截图 (还可以截取某一区域)</li><li>在远程DOM上进行断言测试</li><li>记录事件</li><li>下载资源,包括二进制文件</li><li>编写功能测试套件,结果保存为JUnit XML文件</li><li>抓取网页内容</li></ul></blockquote><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最初的想法是想做一套前端流程测试，每次手动重复测试总是很烦的，流程是这样子的:</p><p><code>用户登录 --&gt; 选择商品 --&gt; 下单 --&gt; 跳转到收银台 --&gt; 确认付款</code>。</p><p>当然这个流程并没有看起来这么简单，必须要模拟用户的网页操作，比如：</p><ol><li>登录这步得解决验证码问题</li><li>不同的付款方式：快捷支付得发送短信，支付宝二维码，微信二维码，跳转到其他的平台支付等。</li></ol><p>然后使用 PhantomJS 来模拟用户操作，当然各种问题还在解决中。</p><p>在试图解决问题的时候，首先调研了下一些前端测试框架，主要是 UI 测试、流程测试方面的，做了一些尝试。</p><h3 id="起手式"><a href="#起手式" class="headerlink" title="起手式"></a>起手式</h3><p>首先我们来看下 <a href="https://github.com/ariya/phantomjs">PhantomJS</a> 的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> page = <span class="built_in">require</span>(<span class="string">'webpage'</span>).create()             <span class="comment">//新建一个页面</span></div><div class="line">page.open(url1, <span class="function"><span class="keyword">function</span>(<span class="params">status</span>) </span>&#123;                  <span class="comment">//导航到第一个URL</span></div><div class="line">    <span class="keyword">if</span> (status == <span class="string">"fail"</span>) phantom.exit()           <span class="comment">//如果发生错误,退出程序</span></div><div class="line">    page.open(url2, <span class="function"><span class="keyword">function</span>(<span class="params">status</span>) </span>&#123;              <span class="comment">//否则在页面加载完成的回调函数中继续导航到第二个URL,依次类推</span></div><div class="line">        <span class="keyword">if</span> (status == <span class="string">"fail"</span>) phantom.exit()</div><div class="line">        page.open(url3, <span class="function"><span class="keyword">function</span>(<span class="params">status</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (status == <span class="string">"fail"</span>) phantom.exit()</div><div class="line">            page.open(url4, <span class="function"><span class="keyword">function</span>(<span class="params">status</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (status == <span class="string">"fail"</span>) phantom.exit()</div><div class="line">                <span class="comment">// 我可以停下来了吗?</span></div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>这是一个在 PhantomJS 中使用链式回调来进行导航操作的例子，写起来相当痛苦。</p><p>比对一下使用 Casperjs</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> casper = <span class="built_in">require</span>(<span class="string">'casper'</span>).create()           <span class="comment">//新建一个页面</span></div><div class="line">casper.start(url1)                                <span class="comment">//添加第一个URL</span></div><div class="line">casper.thenOpen(url2)                             <span class="comment">//添加第二个URL,依次类推</span></div><div class="line">casper.thenOpen(url3)</div><div class="line">casper.thenOpen(url4)</div><div class="line">casper.run()</div></pre></td></tr></table></figure><p>异步操作更方便了，更多的 API 看官方文档 <a href="http://docs.casperjs.org/en/latest/" target="_blank" rel="external">http://docs.casperjs.org/en/latest/</a> 。</p><h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><p>以上简单介绍了下使用方法，现在使用 Casperjs 来做点实际的尝试。</p><p>注册账户：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> casper = <span class="built_in">require</span>(<span class="string">'casper'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出信息</span></div><div class="line"><span class="keyword">var</span> ca = casper.create(&#123;</div><div class="line">  <span class="attr">verbose</span>: <span class="literal">true</span>, <span class="comment">// 实时输出</span></div><div class="line">  logLevel: <span class="string">'debug'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 输出 dom 页面执行的 console 信息</span></div><div class="line">ca.on(<span class="string">'remote.message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.echo(msg, <span class="string">'COMMENT'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'iamrobot1'</span>,</div><div class="line">  <span class="attr">email</span>: <span class="string">'iamrobot1@gmail.com'</span>, <span class="comment">// 假邮箱</span></div><div class="line">  password: <span class="string">'iamrobot1'</span> <span class="comment">// 密码需要包含数字</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> signupUrl = <span class="string">'https://github.com/join?source=header-home'</span></div><div class="line">ca.start(signupUrl) <span class="comment">// 打开页面</span></div><div class="line">  .thenEvaluate(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">    <span class="comment">// 加载完页面，执行 js 处理表单</span></div><div class="line">    <span class="keyword">var</span> form = <span class="built_in">document</span>.forms[<span class="number">1</span>]</div><div class="line">    form[<span class="string">'user[login]'</span>].value = user.name</div><div class="line">    form[<span class="string">'user[email]'</span>].value = user.email</div><div class="line">    form[<span class="string">'user[password]'</span>].value = user.password</div><div class="line">    form.submit()</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'First, create a new user'</span>)</div><div class="line">&#125;, user)</div><div class="line"></div><div class="line">ca.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.echo(<span class="string">'Done!'</span>) <span class="comment">// 注意这里</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 启动</span></div><div class="line">ca.run(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 执行完任务，记得退出</span></div><div class="line">  ca.exit()</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>以上方式可以注册账户，然后接下来就可以干点其他事了…</p><p>当然上面方式只能注册一个账户，当我想注册多个账户时，当然写一个循环，然后随机创建信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (count &gt;= num) &#123;</div><div class="line">    ca.exit()</div><div class="line">    process.exit()</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  .... <span class="comment">// 注册过程</span></div><div class="line"></div><div class="line">  ca.run(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    count++</div><div class="line">    start()</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="在这过程中，遇到几个可以记一下的东西："><a href="#在这过程中，遇到几个可以记一下的东西：" class="headerlink" title="在这过程中，遇到几个可以记一下的东西："></a>在这过程中，遇到几个可以记一下的东西：</h4><ol><li>exit 方法是一个异步的过程。</li><li>start/open 方法打开新的页面，类似于浏览器打开新的 tab。</li><li>casper.create 只能创建一次。</li></ol><p>关于第三点查看 <a href="http://stackoverflow.com/questions/25883624/declare-two-or-more-casper-in-a-single-script" target="_blank" rel="external">Declare two or more casper in a single script</a>。</p><p>所以要注册多个账户的时候需要先退出登录。</p><h4 id="疑惑："><a href="#疑惑：" class="headerlink" title="疑惑："></a>疑惑：</h4><ol><li>监听 <code>exit</code> 事件，打开多个页面，最后会触发多次</li><li><code>waitFor</code> 设置 <code>timeout</code> 无效，貌似只能在 <code>create</code> 的时候设置 <code>stepTimeout</code>，或者说是要比 <code>stepTimeout</code> 值要小？</li><li>操作步骤多的时候，会经常出现这个错误 <a href="https://github.com/casperjs/casperjs/issues/1689">Maximum step execution timeout exceeded for step</a></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>PhantomJS 对 ES6 支持不友好，let 也没法使用。</li><li>不能 require Nodejs 的 native 方法，所以 npm 安装的很多模块就不能使用了，<a href="http://phantomjs.org/api/" target="_blank" rel="external">API 文档</a>。</li></ol><h3 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h3><ol><li>使用 npm 安装 phantomjs-prebuilt，替代全局安装 phantomjs</li><li>不推荐使用 phantomjs-node</li><li>推荐 <a href="https://github.com/marak/Faker.js/">faker.js</a> 创建模拟数据</li><li>推荐<a href="https://github.com/ckknight/random-js">random-js</a> 创建随机数据</li><li>上传图片接口 <a href="http://phantomjs.org/api/webpage/method/upload-file" target="_blank" rel="external">upload-file</a></li></ol><p>暂时就这些。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>使用 CasperJS/PhantomJS 可以做很多自动化的事，值得尝试，不怕被辞…</p><p>最后，用 Python 的朋友可以看下这个 <a href="http://docs.seattlerb.org/mechanize/" target="_blank" rel="external">mechanize</a>，类似 PhantomJS 的 Python 实现。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p><a href="http://docs.casperjs.org/en/latest/" target="_blank" rel="external">CasperJS</a><br><a href="http://phantomjs.org/documentation/" target="_blank" rel="external">PhantomJS</a><br><a href="https://www.npmjs.com/package/phantomjs-prebuilt" target="_blank" rel="external">phantomjs-prebuilt</a><br><a href="https://github.com/amir20/phantomjs-node">phantomjs-node</a><br><a href="http://www.cnblogs.com/ziyunfei/archive/2012/09/27/2706254.html" target="_blank" rel="external">[译]CasperJS,基于PhantomJS的工具包</a><br><a href="https://nicolas.perriault.net/code/2012/casperjs-hits-1-0-stable/" target="_blank" rel="external">Nicolas’s blog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这不是一篇介绍使用 CasperJS 进行单元测试的文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="单元测试" scheme="http://github.com/xwartz/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
      <category term="CasperJS" scheme="http://github.com/xwartz/tags/CasperJS/"/>
    
  </entry>
  
  <entry>
    <title>前端如何 Mock 数据</title>
    <link href="http://github.com/xwartz/2016/09/mock-server/"/>
    <id>http://github.com/xwartz/2016/09/mock-server/</id>
    <published>2016-09-16T15:02:10.000Z</published>
    <updated>2016-12-31T02:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端在开发的阶段，往往依赖后端的接口，应该如何减少甚至摆脱这种依赖呢。</p><a id="more"></a><p>首先应该做的是前后端分离，这里说的仅仅是开发分离，至于发布分离就更好了，</p><p>但是会有坑，这里不展开说，毕竟只是考虑过，还没有实践过。</p><p>前后端分离的明显例子就是单页面应用，后端只需要在首次打开页面的时候返回基本的 <code>html</code> 文件，</p><p>用来加载 <code>js</code>, <code>css</code> 等静态资源(如果考虑首屏性能，可以考虑同构直出的方式)。</p><p>接下来后端就只提供接口，其他剩下的事由前端来处理，包括模板渲染、路由跳转。</p><p>那么，前端相对于后端只有接口的依赖，在开发阶段，只需要模拟接口数据，就可以不依赖后端进行开发了。</p><h3 id="Mock-的方式"><a href="#Mock-的方式" class="headerlink" title="Mock 的方式"></a>Mock 的方式</h3><p>前端模拟 API 数据方式有很多。</p><h4 id="手动模拟"><a href="#手动模拟" class="headerlink" title="手动模拟"></a>手动模拟</h4><p>最不用动脑的方式，在开发的时候，对于接口的调用，直接返回想要的数据，也就是写死数据，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> getData = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 在模拟的时候不走接口请求直接返回数据</span></div><div class="line">  <span class="keyword">return</span> cb &amp;&amp; cb(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)</div><div class="line">  <span class="comment">// 真实的请求</span></div><div class="line">  http.get(<span class="string">'/api/test'</span>, (res) =&gt; &#123;</div><div class="line">    cb &amp;&amp; cb(res)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方式基本没啥优点，在和后端联调的时候，必须把模拟的数据删除，当然你也可以做个封装加个开关，但是还是很不方便。</p><h4 id="重写-Ajax"><a href="#重写-Ajax" class="headerlink" title="重写 Ajax"></a>重写 <code>Ajax</code></h4><p>如果你用 <code>Ajax</code> 请求服务器接口，可以考虑重写 <code>Ajax</code> 方法，代理到 mock server。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _ajax = $.ajax</div><div class="line">$.ajax = <span class="function"><span class="params">option</span> =&gt;</span> &#123;</div><div class="line">  option[<span class="string">'dataType'</span>] = <span class="string">'jsonp'</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (option[<span class="string">'url'</span>]) &#123;</div><div class="line">    <span class="keyword">let</span> reg = <span class="regexp">/http[^\s]+com/i</span></div><div class="line">    <span class="comment">// 带域名的情况处理</span></div><div class="line">    <span class="keyword">if</span> (reg.test(option[<span class="string">'url'</span>])) &#123;</div><div class="line">      option[<span class="string">'url'</span>] = option[<span class="string">'url'</span>].replace(reg, <span class="string">''</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将 url 全都代理到 mock server</span></div><div class="line">    option[<span class="string">'url'</span>] = <span class="string">'http://mock-server/'</span> + option[<span class="string">'url'</span>]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  option[<span class="string">'type'</span>] = <span class="string">'GET'</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> _ajax(option)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样只需要在本地开发的时候，引入这段重写 <code>Ajax</code> 方法的脚本，就可以在开发阶段将 <code>API</code> 请求全部代理到指定的服务器。</p><p>存在几个缺点：</p><ol><li>用这个方式的前提是，你应该有一个可以 mock 的服务，即调用 <code>API</code> 返回相应的数据。</li><li>为了解决跨域，服务得支持 <code>jsonp</code>。</li><li>所有 <code>Ajax</code> 请求都会被代理，也许我们存在部分请求不需要代理(当然也可以增加配置项)。</li></ol><h4 id="使用-Webpack-代理"><a href="#使用-Webpack-代理" class="headerlink" title="使用 Webpack 代理"></a>使用 Webpack 代理</h4><p><code>Webpack</code> 功能强大，不仅仅可以作为 <code>bundler</code> 工具，还可以用来代理请求。</p><p>当然原理是启用了 <code>Node</code> 服务，作为中间代理。</p><p>我们看下如何使用：</p><figure class="highlight js"><figcaption><span>webpack.dev.config.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">proxy: &#123;</div><div class="line">  <span class="string">'/api'</span>: &#123;</div><div class="line">    <span class="attr">target</span>: <span class="string">'https://mock-server.com'</span>,</div><div class="line">    <span class="attr">secure</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上，在开发模式下，就可以将带 <code>/api</code> 的请求代理到指定的服务器。</p><p>由于 <code>Webpack</code> 代理支持正则表达式，所以可以指定某些 <code>API</code> 使用代理，更多参数参考官网文档 <a href="http://webpack.github.io/docs/webpack-dev-server.html#proxy" target="_blank" rel="external">webpack-dev-server</a>。</p><p>由此，可以看到使用 <code>Webpack</code> 的方式，解决了使用 <code>Ajax</code> 的后两个缺点。</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>当然使用 <code>Webpack</code> 还有需要注意的地方，也是我自己在使用的时候遇到的。</p><p>本地开发一般情况都是使用 <code>http://localhost:port</code>，当代理的服务器使用 <code>https</code> 的时候，<br>也就是 <code>http -&gt; https</code> 的代理，这个时候需要设置 <code>agent</code> 参数。</p><p>可以参考我在 <code>github</code> 写的列子 <a href="https://github.com/xwartz/koa-react-boilerplate">koa-react-boilerplate</a>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">proxy: &#123;</div><div class="line">  <span class="string">'/api'</span>: &#123;</div><div class="line">    <span class="attr">target</span>: <span class="string">'https://api.github.com/'</span>,</div><div class="line">    <span class="attr">pathRewrite</span>: &#123; <span class="string">'^/api'</span>: <span class="string">''</span> &#125;,</div><div class="line">    <span class="comment">// http -&gt; https 代理</span></div><div class="line">    <span class="comment">// see detail https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-http-to-https.js</span></div><div class="line">    agent: https.globalAgent,</div><div class="line">    <span class="attr">headers</span>: &#123;</div><div class="line">      <span class="attr">host</span>: <span class="string">'api.github.com'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是一个显示 <code>github</code> 用户 star 信息的例子，将 <code>/api</code> 请求代理到 <code>https://api.github.com/</code>。</p><p>关于更多的 <code>https -&gt; http</code> 与 <code>https -&gt; https</code> 可以参考 <a href="https://github.com/nodejitsu/node-http-proxy#using-https">node-http-proxy</a>。</p><h4 id="Nginx-代理"><a href="#Nginx-代理" class="headerlink" title="Nginx 代理"></a>Nginx 代理</h4><p>Nginx 的反向代理功能还是在现在的工作中使用了，才有所了解。</p><figure class="highlight"><figcaption><span>nginx.conf </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">  listen 80;</div><div class="line">  # 把所有 uri 以 /api 开头的转发到接口服务器</div><div class="line">  location /api &#123;</div><div class="line">    proxy_pass http://127.0.0.1:4000;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Nginx 了解的并不是很多，就不展开讨论了，还望人指点。</p><h3 id="Mock-Server"><a href="#Mock-Server" class="headerlink" title="Mock Server"></a>Mock Server</h3><p>以上，说的都是如何模拟数据，方便本地开发，但是代理接口请求之后，还需要接受该请求的服务器。</p><p>所以一个完整的数据模拟，应该包含 Mock Server。</p><h4 id="可以使用的-Mock-Server"><a href="#可以使用的-Mock-Server" class="headerlink" title="可以使用的 Mock Server"></a>可以使用的 Mock Server</h4><p>存在很多服务，可以使用，有以下推荐：</p><ol><li><a href="https://apiary.io/" target="_blank" rel="external">apiary</a>: 可以生成文档，但是非个人使用得付费。</li><li><a href="https://github.com/thx/RAP">RAP</a>: 功能貌似很强大，阿里妈妈MUX团队出品。</li><li><a href="https://github.com/typicode/json-server">json-server</a>: Node 编写，适合前端人员使用，但不能产生文档。</li></ol><h4 id="构建-Mock-Server"><a href="#构建-Mock-Server" class="headerlink" title="构建 Mock Server"></a>构建 Mock Server</h4><p>综上，有不少提供 mock 的服务，但还是无法完全满足自己的需求，我认为 Mock Server 应该包含以下几点功能：</p><ol><li>友好的交互界面</li><li>录入/保存接口数据</li><li>分项目存储接口数据，适合不同团队使用</li><li>响应请求，返回相应数据</li><li>生成接口文档，方便前后端查阅</li><li>支持接口自动化测试<br>….</li></ol><p>以上，准备自己撸一个 <a href="https://github.com/xwartz/lula">Lula</a> 玩玩。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://cnodejs.org/topic/567d612c435249f221f53a89" target="_blank" rel="external">用于生成API的文档的方案总结</a><br><a href="https://www.zhihu.com/question/35436669" target="_blank" rel="external">你是如何构建 Web 前端 Mock Server 的</a><br><a href="https://zhuanlan.zhihu.com/p/20669111?refer=purerender" target="_blank" rel="external">React 同构实践与思考</a><br><a href="https://github.com/typicode/json-server">json-server</a><br><a href="https://apiary.io/" target="_blank" rel="external">apiary</a><br><a href="https://github.com/thx/RAP">RAP</a><br><a href="http://www.restran.net/2015/08/19/nginx-frontend-helper/" target="_blank" rel="external">Nginx 是前端工程师的好帮手</a><br><a href="https://github.com/nodejitsu/node-http-proxy#using-https">node-http-proxy</a><br><a href="https://github.com/xwartz/koa-react-boilerplate">koa-react-boilerplate</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端在开发的阶段，往往依赖后端的接口，应该如何减少甚至摆脱这种依赖呢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
      <category term="mock" scheme="http://github.com/xwartz/tags/mock/"/>
    
      <category term="proxy" scheme="http://github.com/xwartz/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>Plan</title>
    <link href="http://github.com/xwartz/2016/09/need-to-plan/"/>
    <id>http://github.com/xwartz/2016/09/need-to-plan/</id>
    <published>2016-09-05T05:40:57.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>太多有趣的事，感觉身体被掏空。</p><a id="more"></a><p>以前很不喜欢做计划，认为计划赶不上变化。</p><p>很多事情，只要靠着热情去推动就好，不需要计划的约束。</p><p>最近，感觉精神状态不怎么好，视力应该又差了不少。</p><p>翻了下，TODO LIST、Pocket、Eventnote，堆积了很多事。</p><p>热情这种东西有些时候，感觉适得其反，把人搞得很累，成就感却不高。</p><p>翻了 GitHub 上的活跃记录，有时候一天 10 几个小时，需要节制点才行。</p><p>想着不能再任由兴趣热情驱使，需要系统地学习点东西，培养些兴趣爱好。</p><p>在 Calendar 上写了点计划，约束下自己，自律成自然便好了。</p><p>先完成个小目标，一个月后看看是什么样子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;太多有趣的事，感觉身体被掏空。&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="http://github.com/xwartz/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>URL 编码</title>
    <link href="http://github.com/xwartz/2016/08/URI-encoding/"/>
    <id>http://github.com/xwartz/2016/08/URI-encoding/</id>
    <published>2016-08-20T09:59:04.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>URL</code> 编码，此前只是一知半解，所以就踩到坑了，故此一记。</p><a id="more"></a><h3 id="URI-与-URL"><a href="#URI-与-URL" class="headerlink" title="URI 与 URL"></a><code>URI</code> 与 <code>URL</code></h3><p><code>URI</code>：(Uniform Resource Identifier 的缩写，统一资源标识符)。</p><p><code>URL</code>：(Uniform Resource Locator 的缩写，统一资源定位符)。</p><h5 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h5><p><code>URI</code> 属于 <code>URL</code> 更低层次的抽象，一种字符串文本标准。</p><p>二者的区别在于，<code>URI</code> 表示请求服务器的路径，定义这么一个资源。而 <code>URL</code> 同时说明要如何访问这个资源（<a href="http://）。" target="_blank" rel="external">http://）。</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>由于融合 xx界 和 xx街 的业务，前者的提现功能通过 <code>iframe</code> 加载后者的提现页面来完成。<br>此时，会将前者的 <code>userId</code> 通过 <code>rsa</code> 加密之后拼接到 <code>URL</code> 中，<br>后者获取 <code>userId</code> 之后会与后端做些交互。</p></blockquote><p>首先，简单将 <code>URL</code> 表示为 “<a href="http://127.0.0.1:8043/wallet/withdraw?userId=Exft+f4&quot;，" target="_blank" rel="external">http://127.0.0.1:8043/wallet/withdraw?userId=Exft+f4&quot;，</a><br>那么要获取的 <code>userId</code> 就是 <code>Exft+f4</code>。</p><p>在测试的时候，发现有些账号没有问题，有些账号出现问题，感觉是一个偶然性的问题，然后继续追踪。</p><p>首先查看日志，确定 <code>userId</code> 字段出现问题，存在账号 <code>userId</code> 字段对应不上，解密错误。</p><p><code>Exft+f4</code> 中的 <code>+</code> 被转义成了 <code>空格</code>，也就是变成了 <code>Exft f4</code>，<br>这就很奇怪了，我明明直接在控制台获取的 <code>userId</code> 就是 <code>Exft+f4</code> 啊。</p><p>然后打开 <code>Chrome Network</code> 查看请求发现，<code>query</code> 被自动转义了，如下图</p><p><img src="./encode.png" alt=""></p><p>也就是当服务器获取 <code>query string</code> 的时候(PS: 这里使用后端 <code>Java</code> 提供的方法，获取 <code>userId</code> 并调用 <code>Java</code> 同步方法渲染页面)，已经不正确了。</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>既然知道了问题所在，那就简单了。</p><p>首先，看到浏览器中的 <code>view URL encoded</code>，只要切一下，结果就是正确的了。</p><p>原来问题的症结在没有做 <code>encode</code>，所以其实只需要在拼凑 <code>URL</code> 的时候，将 <code>userId</code> 做一下编码就好了。</p><h3 id="encodeURI-和-encodeURIComponent-的区别"><a href="#encodeURI-和-encodeURIComponent-的区别" class="headerlink" title="encodeURI 和 encodeURIComponent 的区别"></a>encodeURI 和 encodeURIComponent 的区别</h3><blockquote><p>The encodeURI() function encodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two “surrogate” characters).</p><p>The encodeURIComponent() function encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two “surrogate” characters).</p></blockquote><p>也就是 <code>encodeURI</code> 对整个 <code>URI</code> 进行编码，而 <code>encodeURIComponent</code> 是对 <code>URI</code> 的组成部分做编码。</p><p class="tip"><br>  <strong>注意</strong>: 然而事实上不止这么点区别，<code>encodeURI</code> 转义的字符也和 <code>encodeURIComponent</code> 不同。<br></p><p><code>encodeURI</code> 不会转义以下字符</p><blockquote><p>1.保留字符: <code>; , / ? : @ &amp; = + $</code><br>  2.非转义的字符: <code>字母 数字 - _ . ! ~ * &#39; ( )</code><br>  3.数字符号 <code>#</code></p></blockquote><p><code>encodeURIComponent</code> 不会转义以下字符</p><blockquote><p>1.非转义的字符: <code>字母 数字 - _ . ! ~ * &#39; ( )</code></p></blockquote><p>以上，<code>encodeURI</code> 无法产生能适用于 <code>HTTP</code> <code>GET</code> 请求的 <code>URI</code>。</p><p>例如对于 <code>XMLHTTPRequests</code>, 因为 <code>&quot;&amp;&quot;</code>, <code>&quot;+&quot;</code>, 和 <code>&quot;=&quot;</code> 不会被编码，然而在 <code>GET</code> 请求中它们是特殊字符，</p><p>所以为了避免服务器收到不可预知的请求，应该使用 <code>encodeURIComponent</code> 进行转义。</p><p>因此，上面的 “<a href="http://127.0.0.1:8043/wallet/withdraw?userId=Exft+f4&quot;，不能简单使用" target="_blank" rel="external">http://127.0.0.1:8043/wallet/withdraw?userId=Exft+f4&quot;，不能简单使用</a> <code>encodeURI</code> 方法来转义。</p><p>而是应该将 <code>userId</code> 单独使用 <code>encodeURIComponent</code> 进行转义后拼接。</p><p>与 <code>encodeURI</code> 和 <code>encodeURIComponent</code> 对应的解码是 <code>decodeURI</code> 和 <code>decodeURIComponent</code>，<br>因此在获取到 <code>URI</code> 之后只需要解码就可以获取到原值。</p><p>获取 <code>URL</code> 参数的正确姿势：</p><script src="https://gist.github.com/xwartz/12678ec6278e4ff9e0bf892d9db2186f.js"></script><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这本应该是一个早就了解的问题，为何会到现在？</p><p>想了下，大概是以下原因：</p><ol><li>此前工作中 <code>URL</code> 很少是特殊字符的，一般为正常英文字符。</li><li>很少需要获取 <code>URL</code> 上的 <code>query</code> 做再请求的参数，即使作为参数，也是已知的字符。</li><li>框架(库)已经做了转码处理。</li><li>此前只是单纯的调用，对其一知半解。</li></ol><p>所以往后需要注意的是对于任何不可控的字符作为 <code>URL</code> 部分的内容都需要用 <code>encodeURIComponent</code> 进行转义。</p><p>目前工作中遇到常见的场景是手动拼接 <code>URL</code>，比如活动页面的回跳，但是一般也不会出现特殊字符、中文等情况。</p><p>还有一个常见的应该就是搜索了吧，需要使用用户输入的关键字作为 <code>keywords</code>，然而用户输入的字符不可控制，因此必然需要转义。</p><p>写到这时，想起在前公司写的搜索，是否有问题呢？去看下…</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI" target="_blank" rel="external">encodeURI</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent" target="_blank" rel="external">encodeURIComponent</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;URL&lt;/code&gt; 编码，此前只是一知半解，所以就踩到坑了，故此一记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Redux 解析</title>
    <link href="http://github.com/xwartz/2016/08/redux-src/"/>
    <id>http://github.com/xwartz/2016/08/redux-src/</id>
    <published>2016-08-09T07:29:18.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>Redux</code> 这么久，理一下。</p><a id="more"></a><p>Redux 为 JavaScript 应用提供可预测化的状态管理。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>使用 <code>Redux</code> 之后，数据的流向可以使用下图来表示：</p><p><img src="./flow.gif" alt="flow"></p><p>(ps：其实图中的 <code>Dispatcer</code> 并不太准确，<code>Redux</code> 没有专门的 <code>Dispatcher</code>, 数据的更新是通过 <code>store</code> 中的 <code>dispatch</code> 方法。)</p><p>从上图我们可以看到清晰的数据流向: <code>View</code> 触发数据更新 —&gt; <code>Actions</code> 将数据传递到 <code>Store</code> —&gt; <code>Store</code> 更新 <code>state</code> —&gt; 更新 <code>View</code>。</p><p><code>Redux</code> 中整个应用的状态存储在一颗 <code>object tree</code> 中，对应一个唯一的 <code>Store</code>，并且 <code>state</code> 是只读的，使用纯函数 <code>reducer</code> 来更新 <code>state</code> 会生成一个新的 <code>state</code> 而不是直接修改原来的。</p><p><code>Redux</code> 通过以上约束试图让 <code>state</code> 的变化可预测。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>Redux</code> 的源码非常少，但是却实现了这样一个数据流的管理，非常值得阅读学习。</p><p><code>Redux</code> 的源码并不是非常容易理解的，包含很多闭包和高阶函数的使用导致理解起来有点绕。</p><p>了解了原理之后，对 <code>Redux</code> 源码的分析，就简单许多。</p><p>源码结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── applyMiddleware.js</div><div class="line">├── bindActionCreators.js</div><div class="line">├── combineReducers.js</div><div class="line">├── compose.js</div><div class="line">├── createStore.js</div><div class="line">├── index.js</div><div class="line">└── utils</div><div class="line">    └── warning.js</div></pre></td></tr></table></figure><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><p>从入口文件 <code>index.js</code> 开始，删除了部分 <code>warning</code> 代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./createStore'</span></div><div class="line"><span class="keyword">import</span> combineReducers <span class="keyword">from</span> <span class="string">'./combineReducers'</span></div><div class="line"><span class="keyword">import</span> bindActionCreators <span class="keyword">from</span> <span class="string">'./bindActionCreators'</span></div><div class="line"><span class="keyword">import</span> applyMiddleware <span class="keyword">from</span> <span class="string">'./applyMiddleware'</span></div><div class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">'./compose'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;</div><div class="line">  createStore,</div><div class="line">  combineReducers,</div><div class="line">  bindActionCreators,</div><div class="line">  applyMiddleware,</div><div class="line">  compose</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上面可以看出，<code>Redux</code> 暴露的顶层 <code>API</code> 就只有 4 个。</p><p>接下来分析每个 <code>API</code> 。</p><h4 id="createStore-js"><a href="#createStore-js" class="headerlink" title="createStore.js"></a>createStore.js</h4><p>用来创建 <code>store</code>，其中暴露 <code>dispatch</code>, <code>subscribe</code>, <code>getState</code>, <code>replaceReducer</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 初始化时，默认传递的 action，默认也应该返回初始化的 state</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> ActionTypes = &#123;</div><div class="line">  <span class="attr">INIT</span>: <span class="string">'@@redux/INIT'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 创建 store, 参数根 reducer, state 以及中间件</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</div><div class="line">    enhancer = preloadedState</div><div class="line">    preloadedState = <span class="literal">undefined</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> currentReducer = reducer</div><div class="line">  <span class="keyword">var</span> currentState = preloadedState</div><div class="line">  <span class="keyword">var</span> currentListeners = []</div><div class="line">  <span class="keyword">var</span> nextListeners = currentListeners</div><div class="line">  <span class="keyword">var</span> isDispatching = <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="comment">// 去除引用</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</div><div class="line">      nextListeners = currentListeners.slice()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Reads the state tree managed by the store.</div><div class="line">   * @returns &#123;any&#125; The current state tree of your application.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> currentState</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 订阅事件，返回移除订阅函数，巧妙的利用了闭包</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> isSubscribed = <span class="literal">true</span></div><div class="line"></div><div class="line">    ensureCanMutateNextListeners()</div><div class="line">    nextListeners.push(listener)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (!isSubscribed) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      isSubscribed = <span class="literal">false</span></div><div class="line"></div><div class="line">      ensureCanMutateNextListeners()</div><div class="line">      <span class="keyword">var</span> index = nextListeners.indexOf(listener)</div><div class="line">      nextListeners.splice(index, <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 执行 reducer，并触发订阅事件</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">    <span class="comment">// https://lodash.com/docs#isPlainObject</span></div><div class="line">    <span class="keyword">if</span> (!isPlainObject(action)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</div><div class="line">        <span class="string">'Actions must be plain objects. '</span> +</div><div class="line">        <span class="string">'Use custom middleware for async actions.'</span></div><div class="line">      )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</div><div class="line">        <span class="string">'Actions may not have an undefined "type" property. '</span> +</div><div class="line">        <span class="string">'Have you misspelled a constant?'</span></div><div class="line">      )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isDispatching) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      isDispatching = <span class="literal">true</span></div><div class="line">      <span class="comment">// 产生新的 state</span></div><div class="line">      currentState = currentReducer(currentState, action)</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      isDispatching = <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 触发订阅的事件</span></div><div class="line">    <span class="keyword">var</span> listeners = currentListeners = nextListeners</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</div><div class="line">      listeners[i]()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> action</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 动态替换 reducer</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    currentReducer = nextReducer</div><div class="line">    dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    dispatch,</div><div class="line">    subscribe,</div><div class="line">    getState,</div><div class="line">    replaceReducer</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="combineReducers-js"><a href="#combineReducers-js" class="headerlink" title="combineReducers.js"></a>combineReducers.js</h3><p><code>combineReducers</code> 用于拆分 <code>reducer</code>，拆分后的每一块独立负责管理 <code>state</code> 的一部分，方便管理复杂的应用。</p><p><code>combineReducers</code> 返回一个函数可以将传入的 <code>reducers</code> 都调用一遍合成一个大的 <code>state</code>。</p><p>比如有 <code>reducer</code>: r1, r2, r3;<br>将 <code>{ r1, r2, r3 }</code> 传入 <code>combineReducers</code> 将返回一个可以产生这样的 <code>state</code>: <code>{ r1: {}, r2: {}, r3: {} }</code>  的函数。</p><p>其中很长一段代码都是对 <code>reducers</code> 合法性的检测，这里只需要分析下 <code>combineReducers</code> 函数的实现，一些代码已经删除掉了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</div><div class="line">  <span class="comment">// 将 reducers 存储在一个对象中</span></div><div class="line">  <span class="keyword">var</span> finalReducers = &#123;&#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> key = reducerKeys[i]</div><div class="line">    </div><div class="line">    ... 省略 <span class="string">`reducer`</span> 的合理性检测</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</div><div class="line">      finalReducers[key] = reducers[key]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</div><div class="line"></div><div class="line">  ...省略 <span class="string">`reducer`</span> 的不合理的处理</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</div><div class="line">  </div><div class="line">    <span class="keyword">var</span> hasChanged = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> nextState = &#123;&#125;</div><div class="line">    <span class="comment">// 遍历调用 reducers，产生一个大的 state，key 和 reducer 名对应 </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</div><div class="line">      <span class="keyword">var</span> key = finalReducerKeys[i]</div><div class="line">      <span class="keyword">var</span> reducer = finalReducers[key]</div><div class="line">      <span class="keyword">var</span> previousStateForKey = state[key]</div><div class="line">      <span class="keyword">var</span> nextStateForKey = reducer(previousStateForKey, action)</div><div class="line">      </div><div class="line">      nextState[key] = nextStateForKey</div><div class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="bindActionCreators-js"><a href="#bindActionCreators-js" class="headerlink" title="bindActionCreators.js"></a>bindActionCreators.js</h4><p>类似 <code>combineReducers</code>, <code>bindActionCreators</code> 函数把 <code>action creators</code> 转成拥有同名 <code>keys</code> 的对象，<br>并使用 <code>dispatch</code> 把每个 <code>action creator</code> 包装起来，这样在调用 <code>action</code> 时可以直接调用 <code>dispatch</code>。</p><p>也就是说不需要将 <code>dispatch</code> 手动传入到子组件中了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 action 外部包装一层 dispatch</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(actionCreator(...args))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果是函数，这种情况一般就只有一个 action</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// 遍历 actions ，包装一层 dispatch</span></div><div class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(actionCreators)</div><div class="line">  <span class="keyword">var</span> boundActionCreators = &#123;&#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> key = keys[i]</div><div class="line">    <span class="keyword">var</span> actionCreator = actionCreators[key]</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</div><div class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> boundActionCreators</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="compose-js"><a href="#compose-js" class="headerlink" title="compose.js"></a>compose.js</h4><p><code>compose</code> 的作用是从右到左来组合多个函数，不使用深度右括号的情况下来写深度嵌套的函数，内部实现其实就是一个 <code>reduceRight</code>。</p><p>关于 <code>reduceRight</code>, 查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight</a></p><p>比如 <code>a(b(c()))</code> 可以这样写 <code>compose(a,b,c)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>]</div><div class="line">  <span class="keyword">const</span> rest = funcs.slice(<span class="number">0</span>, <span class="number">-1</span>)</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> rest.reduceRight(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), last(...args))</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="applyMiddleware-js"><a href="#applyMiddleware-js" class="headerlink" title="applyMiddleware.js"></a>applyMiddleware.js</h4><p><code>applyMiddleware</code> 最终返回的是一个作用了 <code>middlewares</code> 的 <code>store</code>。</p><p>之后 <code>store.dispatch</code> 的调用都会经历各个 <code>middleware</code>，所以你就可以在中间件中做一些额外的事情，比如打印日志。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">'./compose'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</div><div class="line">  <span class="comment">// 返回一个接收 createStore 的函数</span></div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> </div><div class="line">    <span class="comment">// 返回一个接收 reducer, preloadedState, enhancer 的函数</span></div><div class="line">    (reducer, preloadedState, enhancer) =&gt; &#123;</div><div class="line">    <span class="comment">// 创建 store</span></div><div class="line">    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer)</div><div class="line">    <span class="keyword">var</span> dispatch = store.dispatch</div><div class="line">    <span class="keyword">var</span> chain = []</div><div class="line"></div><div class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</div><div class="line">      <span class="attr">getState</span>: store.getState,</div><div class="line">      <span class="attr">dispatch</span>: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 作用每个 middleware</span></div><div class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</div><div class="line">    <span class="comment">// 将 dispatch 传给最后一个 middleware</span></div><div class="line">    dispatch = compose(...chain)(store.dispatch)</div><div class="line"></div><div class="line">    <span class="comment">// 返回作用 middleware 之后的 store</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      ...store,</div><div class="line">      dispatch</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>每个 <code>middleware</code> 接受 <code>Store</code> 的 <code>dispatch</code> 和 <code>getState</code> 函数作为命名参数，并返回一个函数。<br>该函数会被传入 被称为 <code>next</code> 的下一个 <code>middleware</code> 的 <code>dispatch</code> 方法，并返回一个接收 <code>action</code> 的新函数，<br>这个函数可以直接调用 <code>next(action)</code>，或者在其他需要的时刻调用，甚至根本不去调用它。</p><p>调用链中最后一个 <code>middleware</code> 会接受真实的 <code>store</code> 的 <code>dispatch</code> 方法作为 <code>next</code> 参数，并借此结束调用链。</p><p>所以，<code>middleware</code> 的函数签名是 <code>({ getState, dispatch }) =&gt; next =&gt; action</code>。</p><p>一个简单 <code>middleware</code> 可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">&#123; getState &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">next</span>) =&gt;</span> (action) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'will dispatch'</span>, action)</div><div class="line"></div><div class="line">    <span class="comment">// 调用 middleware 链中下一个 middleware 的 dispatch。</span></div><div class="line">    <span class="keyword">let</span> returnValue = next(action)</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'state after dispatch'</span>, getState())</div><div class="line"></div><div class="line">    <span class="comment">// 一般会是 action 本身，除非</span></div><div class="line">    <span class="comment">// 后面的 middleware 修改了它。</span></div><div class="line">    <span class="keyword">return</span> returnValue</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当调用 <code>store.dispatch</code> 之后，会打印出 <code>will dispatch xxx</code>, <code>state after dispatch xxx</code> 信息。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>Redux</code> 的代码里使用高阶函数来简化代码，但是让人阅读起来并不容易理解，总感觉有些绕。</p><p>感觉自己平时多层嵌套函数用的太少了，逻辑都快转不过来了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;Redux&lt;/code&gt; 这么久，理一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 继承</title>
    <link href="http://github.com/xwartz/2016/08/javascript-inheritance/"/>
    <id>http://github.com/xwartz/2016/08/javascript-inheritance/</id>
    <published>2016-08-04T01:30:20.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 JavaScript 继承的回顾。</p><a id="more"></a><blockquote><p><code>JavaScript</code> 是一种基于原型的面向对象语言，而不是基于类的。<br>  正是由于这一根本的区别，其如何创建对象的层级结构以及对象的属性与属性值是如何继承的并不是那么清晰。</p></blockquote><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象就是一系列属性的集合，属性就是键值对 <code>key: value</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  <span class="attr">x</span>: <span class="number">10</span>,</div><div class="line">  <span class="attr">y</span>: <span class="number">20</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>JavaScript</code> 中的继承其实就是对象与对象之间层级结构关系的讨论。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>在 <code>JavaScript</code> 中，每个对象都有一个指向它的原型 <code>prototype</code> 对象的内部链接。<br>这个原型对象又有自己的原型，直到某个对象的原型为 <code>null</code> 为止。这种一级一级的链结构就称为原型链（prototype chain）。</p><p>对象原型指定可以使用 <code>__proto__</code> 属性。</p><p class="tip"><br>根据 ECMAScript 标准，someObject.[[Prototype]] 符号是用于指派 someObject 的原型。<br>这个等同于 JavaScript 的 <code>__proto__</code>  属性（现已弃用）。<br>从 ECMAScript 6 开始, [[Prototype]] <code>可以用 Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code> 访问器来访问。<br></p><p>也就是说，以下涉及到 <code>__proto__</code> 的方式，都可以使用 <code>Object.getPrototypeOf()</code> 来获取原型，或者使用 <code>Object.setPrototypeOf()</code> 来设置原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  <span class="attr">x</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">y</span>: <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = &#123;&#125;</div><div class="line"></div><div class="line">b.__proto__ = a <span class="comment">// 将对象的原型指向 a, 等同于 b = Object.setPrototypeOf(&#123;&#125;, a)</span></div><div class="line"></div><div class="line">b.x <span class="comment">// 1</span></div><div class="line">b.y <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>其实 <code>new</code> 关键字会做类似的操作，在构造函数下会做说明。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在 <code>JavaScript</code> 中构造函数就是一个函数，可以使用 <code>new</code> 操作符作用这个函数，实例化一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.y = y</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.x = <span class="number">1</span></div><div class="line"></div><div class="line">Foo.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实例化对象 b</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="number">2</span>)</div><div class="line"></div><div class="line">b.x <span class="comment">// 1</span></div><div class="line">b.y <span class="comment">// 2</span></div><div class="line"></div><div class="line">b.__proto__ === Foo.prototype <span class="comment">// true, 等同于 Object.setPrototypeOf(b) === Foo.prototype</span></div><div class="line"></div><div class="line"><span class="comment">// constructor 返回一个指向创建了该对象原型的函数引用</span></div><div class="line">b.constructor === Foo <span class="comment">// true</span></div><div class="line"></div><div class="line">Foo.prototype.constructor === Foo <span class="comment">// true</span></div><div class="line"></div><div class="line">b.fn === b.__proto__.fn <span class="comment">// true</span></div><div class="line"></div><div class="line">b.__proto__.fn === Foo.prototype.fn <span class="comment">// true</span></div></pre></td></tr></table></figure><img src="/blog/2016/08/javascript-inheritance/1.png" alt="1.png" title=""><p>从以上结果可以推测，当执行 <code>new</code> 操作符时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="number">2</span>)</div></pre></td></tr></table></figure><p><code>JavaScript</code> 实际上执行了以下操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>()</div><div class="line">b.__proto__ = Foo.prototype</div><div class="line">Foo.call(b, <span class="number">2</span>)</div></pre></td></tr></table></figure><p>知道了原理之后，我们就可以使用构造函数的方式来实现继承了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Bar 继承 Foo</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="comment">// 继承构造函数中的属性</span></div><div class="line">  Foo.call(<span class="keyword">this</span>, x)</div><div class="line">  <span class="comment">// 增加属性</span></div><div class="line">  <span class="keyword">this</span>.y = y</div><div class="line">&#125;</div><div class="line"><span class="comment">// 继承原型链上的属性</span></div><div class="line"><span class="comment">// 这里有个不优雅的地方是会在 Bar 原型连上产生一个 Foo 自身的属性 x undefined</span></div><div class="line">Bar.prototype = <span class="keyword">new</span> Foo()</div><div class="line"></div><div class="line"><span class="comment">// 如果 Bar.prototype = Foo.prototype, 除了构造函数 Bar 和 Foo 其实是一样的</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="number">1</span>)</div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Bar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line">bar.__proto__ === Bar.prototype <span class="comment">// true</span></div><div class="line">bar.__proto__.__proto__ === foo.__proto__ <span class="comment">// true</span></div></pre></td></tr></table></figure><h5 id="总得来说，要实现继承分两步走："><a href="#总得来说，要实现继承分两步走：" class="headerlink" title="总得来说，要实现继承分两步走："></a>总得来说，要实现继承分两步走：</h5><ol><li>继承构造函数里的属性(父类自身的属性)</li><li>继承原型链上的属性</li></ol><h3 id="Object-create-实现继承"><a href="#Object-create-实现继承" class="headerlink" title="Object.create 实现继承"></a>Object.create 实现继承</h3><blockquote><p><code>Object.create()</code> 方法创建一个拥有指定原型和若干个指定属性的对象。</p></blockquote><p><em>这是一个 <code>ES5</code> 中的方法，IE &gt;= 9。</em></p><p>使用 <code>Object.create()</code> 来解决上面子类原型链上产生父类自身属性的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Bar 继承 Foo</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="comment">// 继承构造函数中的属性</span></div><div class="line">  Foo.call(<span class="keyword">this</span>, x)</div><div class="line">  <span class="comment">// 增加属性</span></div><div class="line">  <span class="keyword">this</span>.y = y</div><div class="line">&#125;</div><div class="line"><span class="comment">// 继承原型链上的属性</span></div><div class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype)</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="number">1</span>)</div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Bar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line">bar.__proto__ === Bar.prototype <span class="comment">// true</span></div><div class="line">bar.__proto__.__proto__ === foo.__proto__ <span class="comment">// true</span></div></pre></td></tr></table></figure><h3 id="class-关键字"><a href="#class-关键字" class="headerlink" title="class 关键字"></a>class 关键字</h3><p>ES6 加入语法糖 <code>class</code>，实现继承就更加方便一些了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="comment">// 构造函数</span></div><div class="line">  <span class="keyword">constructor</span>(x) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 原型链上的方法</span></div><div class="line">  fn () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="comment">// 子类构造函数</span></div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">super</span>(x) <span class="comment">// 访问父对象上的构造函数</span></div><div class="line">    <span class="keyword">this</span>.y = y</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="number">1</span>)</div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Bar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line">bar.__proto__.__proto__ === foo.__proto__ <span class="comment">// true</span></div></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><blockquote><p>某些面向对象语言支持多重继承。也就是说，对象可以从无关的多个父对象中继承属性和属性值。JavaScript 不支持多重继承。</p></blockquote><p>在 <code>JavaScript</code> 中，可以在构造器函数中调用多个其它的构造器函数。这一点造成了多重继承的假象。例如，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.y = y</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Baz</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  Foo.call(<span class="keyword">this</span>, x)</div><div class="line">  Bar.call(<span class="keyword">this</span>, y)</div><div class="line">&#125;</div><div class="line"></div><div class="line">Baz.prototype = <span class="keyword">new</span> Bar()</div><div class="line"></div><div class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> Baz(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// &#123;x: 1, y: 2&#125;</span></div></pre></td></tr></table></figure><p>以上看起来 baz 的属性 <code>{x: 1, y: 2}</code> 中包含了 <code>Foo</code> 和 <code>Bar</code> 的属性，但是更新 <code>Foo</code> 的原型链上的属性，并不会被继承下来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Foo.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure><p>实例 baz 还是原来的样子，并没有 fn 属性。<br>当然你可以把 <code>Foo</code> 的原型链上的属性复制到 Baz 的 <code>prototype</code> 上，但之后 <code>Foo</code> 原型链上属性的更新并不会被继承。</p><p>造成这个的原因是: <code>JavaScript</code> 的继承是在运行时通过检索对象的原型链来实现的。因为对象只有一个原型与之关联，所以 <code>JavaScript</code> 无法动态地从多个原型链中继承。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>总得来说使用 <code>ES6</code> 来实现继承更加方便了，但是了解下原型链还是很有必要的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="external">Object.prototype.<strong>proto</strong></a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="external">Object.prototype.constructor</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects" target="_blank" rel="external">Working with objects</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model" target="_blank" rel="external">Details of the object model</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">Inheritance and the prototype chain</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create()</a></p><p><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" target="_blank" rel="external">JavaScript. The core. (Dmitry A. Soshnikov ECMA-262 article series)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 JavaScript 继承的回顾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>前端单元测试 Jenkins 集成</title>
    <link href="http://github.com/xwartz/2016/08/jenkins-ci-unit-test/"/>
    <id>http://github.com/xwartz/2016/08/jenkins-ci-unit-test/</id>
    <published>2016-08-02T03:15:18.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习下 Jenkins，写个配置教程吧。</p><a id="more"></a><img src="/blog/2016/08/jenkins-ci-unit-test/jenkins.png" alt="jenkins.png" title=""><p>之前写过几篇关于前端<a href="http://xwartz.github.io/pupa/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" target="_blank" rel="external">单元测试的文章</a>，现在结合项目简单写一下如何与 Jenkins 搭配集成。</p><p>关于如何自己搭建 Jenkins 服务就不说了，直接看<a href="https://jenkins.io" target="_blank" rel="external">官方教程</a>。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><img src="/blog/2016/08/jenkins-ci-unit-test/0.png" alt="0.png" title=""><p>填充一下项目信息</p><img src="/blog/2016/08/jenkins-ci-unit-test/2.png" alt="2.png" title=""><h3 id="配置-gitlab"><a href="#配置-gitlab" class="headerlink" title="配置 gitlab"></a>配置 gitlab</h3><h3 id="给-Jenkins-账户添加权限"><a href="#给-Jenkins-账户添加权限" class="headerlink" title="给 Jenkins 账户添加权限"></a>给 Jenkins 账户添加权限</h3><img src="/blog/2016/08/jenkins-ci-unit-test/1.png" alt="1.png" title=""><p>权限选择可以参考文档 <a href="http://docs.gitlab.com/ee/user/permissions.html#gitlab-ci" target="_blank" rel="external">http://docs.gitlab.com/ee/user/permissions.html#gitlab-ci</a></p><h3 id="增加-Web-hooks"><a href="#增加-Web-hooks" class="headerlink" title="增加 Web hooks"></a>增加 Web hooks</h3><img src="/blog/2016/08/jenkins-ci-unit-test/7.png" alt="7.png" title=""><p>根据自身需要选择触发事件。</p><h3 id="选择-Build-分支以及-Build-Triggers"><a href="#选择-Build-分支以及-Build-Triggers" class="headerlink" title="选择 Build 分支以及 Build Triggers"></a>选择 Build 分支以及 Build Triggers</h3><img src="/blog/2016/08/jenkins-ci-unit-test/3.png" alt="3.png" title=""><p>根据自身需要选择。</p><h3 id="编写-Build-Shell"><a href="#编写-Build-Shell" class="headerlink" title="编写 Build Shell"></a>编写 Build Shell</h3><img src="/blog/2016/08/jenkins-ci-unit-test/4.png" alt="4.png" title=""><p>一般根据 <code>package.json</code> 的 <code>scripts</code> 写就好了。</p><p>关于测试脚本编写可以参考 <a href="https://github.com/xwartz/webpack-karma-mocha">https://github.com/xwartz/webpack-karma-mocha</a></p><h3 id="增加-Post-build-Actions"><a href="#增加-Post-build-Actions" class="headerlink" title="增加 Post-build Actions"></a>增加 Post-build Actions</h3><img src="/blog/2016/08/jenkins-ci-unit-test/5.png" alt="5.png" title=""><p>我这里用了<a href="https://wiki.jenkins-ci.org/display/JENKINS/HTML+Publisher+Plugin" target="_blank" rel="external">HTML的插件</a>，会生成 HTML 报告。</p><p>其他一些插件可以查看这里 <a href="https://wiki.jenkins-ci.org/display/JENKINS/Plugins" target="_blank" rel="external">Plugins</a>，可以增加点邮件报告等，根据自己需求来吧。</p><h3 id="生成测试覆盖率"><a href="#生成测试覆盖率" class="headerlink" title="生成测试覆盖率"></a>生成测试覆盖率</h3><img src="/blog/2016/08/jenkins-ci-unit-test/6.png" alt="6.png" title=""><p>最后生成的覆盖率类似这样子的。</p><h3 id="Over"><a href="#Over" class="headerlink" title="Over"></a>Over</h3><p>这里只是简单介绍下怎么配合 <code>Gitlab</code> 仓库使用，其他一些东西还是需要自己去研究研究，<code>Jenkins</code> 在公司内部搭建服务使用还是不错的。</p><p>如果你的项目是开源的话，推荐使用 <a href="https://travis-ci.org/" target="_blank" rel="external">travis-ci</a>，或者花钱支持私有仓库。<br>测试覆盖率搭配 <a href="https://codecov.io/" target="_blank" rel="external">CodeCover</a>，还可以在自己的开源项目上增加几个 logo，给使用的人增加点信心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习下 Jenkins，写个配置教程吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="单元测试" scheme="http://github.com/xwartz/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="code" scheme="http://github.com/xwartz/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>没那么简单</title>
    <link href="http://github.com/xwartz/2016/07/keng/"/>
    <id>http://github.com/xwartz/2016/07/keng/</id>
    <published>2016-07-11T16:41:56.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>挖的坑，总是要有人来填的，不是现在填，就是以后付出更多代价。</p><a id="more"></a><p>来新公司之后，就一直在填坑，重复代码，代码复用性很差，代码无规范，缩进不一致，甚至 tab 和空格混用。。。</p><p>一遇上和后端联调、或者发布的时候，就到半夜。。。</p><p>反正各种能见到的坑，大概都算是见到了，反正坑就在未知的前方，不离不弃。。。</p><p>在前公司的时候，接手项目时，幸好前人的代码风格不错，然后一直照着这风格，让我有一个良好的编程风格。</p><p>一直没有在编辑器里加 <code>eslint</code> 这类的检测工具，也没什么感知，一直用 <code>git</code> 分支管理也很清晰，</p><p>提交了代码相互 code review 一下也能保证风格的统一，<code>commit</code> 清晰。</p><p>开发调试也很方便，单页面应用，模块化，代码复用率高，REST API，模板前端控制，常重构、代码规范统一…</p><p>现在回想，曾经很美。</p><p>所以一路走来，感觉都很不错，学到不少东西，享受到了前端社区这几年带来的便利。</p><p>当然发布也是比较坑，前后端不能分开单独发布，后端 <code>Java</code>，基础模板 <code>VM</code>(其他非单页面应用)，<br>发布时，前端 <code>gulp</code> 构建，等待后端 <code>Java</code> 编译发布，发布效率很低。</p><p>后来也尝试了 <code>Node.js</code> 中间层的前后端分离方案，<code>Node.js</code> 控制模板渲染，<br><code>Java</code> 层只提供接口，前端的接口调用直接指向 <code>Java</code>(这其实在单页面应用时已经做到了)。</p><p>这样就可以分开单独发布了。</p><p>然而当时技能有限，遇到的很多坑填不上…</p><p>一些原因，最后我也走了，最终没能看到上线的样子。</p><p>现在回想，其实当时可以利用一些朋友圈的资源得到些帮助，也许功力就大增了。</p><p>当然，不入现在的坑，可能也体会不到基础架构对后期维护的重要性，可能也体会不到一个完善的 IDE 对于开发的重要性，</p><p>团队的编程习惯、代码风格对于成员的影响，后续的维护等等。</p><p>像 <code>eslint</code>、<code>jslint</code> 这类的 <code>lint</code> 工具在开发、重构时能带来多少好处。</p><p>我想以后不配置好 <code>eslint</code> 我都不愿意写代码了吧。</p><p>前端什么时候能有一个更好的编辑器呢？</p><ul><li>配置 IDE 环境</li><li><code>eslint</code></li><li><del><code>pre-commit</code></del></li><li>老代码 <a href="https://github.com/xwartz/ESLint-Fix">eslint-fix</a></li><li>重构、模块化</li><li><a href="https://github.com/xwartz/webpack-karma-mocha">单元测试</a></li><li>集成测试</li><li>构建脚手架</li><li>写文档、写注释</li></ul><p>慢慢在做一些基础性的东西，填前人留下的坑。</p><p>体会到痛苦之后，才会想怎么提高效率，减小维护成本，怎么工程化。</p><p>基础架构、前后端分离、性能优化、组件化、构建方案、发布流程、静态资源管理、测试、监控…还有很多要学习、思考的。</p><p>前端没那么简单。</p><p>以上，最近不顺，吐槽一番。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;挖的坑，总是要有人来填的，不是现在填，就是以后付出更多代价。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端工程" scheme="http://github.com/xwartz/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>大理</title>
    <link href="http://github.com/xwartz/2016/07/dali/"/>
    <id>http://github.com/xwartz/2016/07/dali/</id>
    <published>2016-07-04T14:54:33.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>01/07 - 04/07 outing.</p><a id="more"></a><img src="/blog/2016/07/dali/1.JPG" alt="1.JPG" title=""><img src="/blog/2016/07/dali/9.JPG" alt="9.JPG" title=""><img src="/blog/2016/07/dali/2.JPG" alt="2.JPG" title=""><img src="/blog/2016/07/dali/3.JPG" alt="3.JPG" title=""><img src="/blog/2016/07/dali/5.JPG" alt="5.JPG" title=""><img src="/blog/2016/07/dali/6.JPG" alt="6.JPG" title=""><img src="/blog/2016/07/dali/7.JPG" alt="7.JPG" title=""><img src="/blog/2016/07/dali/4.JPG" alt="4.JPG" title=""><img src="/blog/2016/07/dali/8.JPG" alt="8.JPG" title=""><!-- more -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;01/07 - 04/07 outing.&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="http://github.com/xwartz/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>使用 Chrome 调试 Node.js</title>
    <link href="http://github.com/xwartz/2016/06/debugging-node-js-nightlies-with-chrome-devtools/"/>
    <id>http://github.com/xwartz/2016/06/debugging-node-js-nightlies-with-chrome-devtools/</id>
    <published>2016-06-25T04:02:11.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近谷歌程序员动作挺大的，毕竟 Web 发家的，就是厉害啊。</p><a id="more"></a><p>看到 <code>Paul Irish</code> 更新的 <code>medium</code> 文章 <a href="https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27#.f7ybt5s2m" target="_blank" rel="external">Debugging Node.js Nightlies with Chrome DevTools</a>，试了一发，顺便翻译下教程。</p><img src="/blog/2016/06/debugging-node-js-nightlies-with-chrome-devtools/debug.png" alt="debug.png" title=""><p>Node.js Nightlies 版本已经支持使用 <code>Chrome</code> 浏览器来调试了，查看 <a href="https://github.com/nodejs/node/pull/6792">pull</a>。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>下面是关于如何使用 <code>Chrome</code> 来调试 <code>Node.js</code> 的教程</p><h4 id="1-下载-Node-js-Nightly-版本"><a href="#1-下载-Node-js-Nightly-版本" class="headerlink" title="1. 下载 Node.js Nightly 版本"></a>1. 下载 Node.js Nightly 版本</h4><p>使用 <code>Paul Irish</code> 写好的脚本 <a href="https://gist.github.com/paulirish/a02f4aa2b5ce69f5c269d18e74f57ab3" target="_blank" rel="external">https://gist.github.com/paulirish/a02f4aa2b5ce69f5c269d18e74f57ab3</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -O <span class="string">"https://gist.githubusercontent.com/paulirish/a02f4aa2b5ce69f5c269d18e74f57ab3/raw/36003214efb09259f86061656ac04ac846ff9c2f/download-node-nightly.sh"</span></div><div class="line">bash download-node-nightly.sh</div></pre></td></tr></table></figure><p>或者你可以从这里下载想要的版本 <a href="https://nodejs.org/download/nightly/" target="_blank" rel="external">https://nodejs.org/download/nightly/</a></p><h4 id="2-设置别名"><a href="#2-设置别名" class="headerlink" title="2. 设置别名"></a>2. 设置别名</h4><p>将下载的 Node.js 放到任意目录，在 <code>.zshrc</code> 中设置别名 <code>node-nightly</code>，避免与正常使用的 <code>Node.js</code> 冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">alias</span> node-nightly=<span class="string">'~/bin/node-v7.0.0-nightly20160621ecc48a154d-darwin-x64/bin/node'</span></div></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node-nightly --inspect index.js</div></pre></td></tr></table></figure><p>或者使用 <code>--debug-brk</code> 参数，在启动后第一行开始断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node-nightly --inspect --debug-brk index.js</div></pre></td></tr></table></figure><h4 id="在-Chrome-浏览器里打开-URL"><a href="#在-Chrome-浏览器里打开-URL" class="headerlink" title="在 Chrome 浏览器里打开 URL"></a>在 Chrome 浏览器里打开 URL</h4><p>执行上一步操作，会在终端输出 <code>URL</code>，在 <code>Chrome</code> 中打开这个地址。</p><p>以上，你就可以像调试网页一样调试 <code>Node.js</code> 代码了。</p><p>Enjoy.</p><h3 id="其他调试方法"><a href="#其他调试方法" class="headerlink" title="其他调试方法"></a>其他调试方法</h3><p>至于其他的调试方法，知道的大概有下面这些：</p><ol><li><p><a href="https://nodejs.org/api/debugger.html" target="_blank" rel="external">Debugger</a></p></li><li><p><a href="https://github.com/node-inspector/node-inspector">node-inspector</a></p></li><li><p><a href="https://github.com/Jam3/devtool">devtool</a>：基于 <code>Electron</code></p></li><li><p>还有各种编辑器自带的</p></li></ol><p>关于比较可以看这个评论 <a href="https://github.com/nodejs/node/pull/6792#issuecomment-219756916">issuecomment-219756916</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27#.f7ybt5s2m" target="_blank" rel="external">Debugging Node.js Nightlies with Chrome DevTools</a></p><p><a href="https://github.com/nodejs/node/pull/6792">Add v8_inspector support</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近谷歌程序员动作挺大的，毕竟 Web 发家的，就是厉害啊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="devTools" scheme="http://github.com/xwartz/tags/devTools/"/>
    
      <category term="nodejs" scheme="http://github.com/xwartz/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>EditorConfig 介绍</title>
    <link href="http://github.com/xwartz/2016/06/editorconfig/"/>
    <id>http://github.com/xwartz/2016/06/editorconfig/</id>
    <published>2016-06-19T15:47:10.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>基础设施真的很重要，尤其是在经历了几个烂项目之后。</p><a id="more"></a><img src="/blog/2016/06/editorconfig/ill.png" alt="ill.png" title=""><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于最近比较关注前端工程化方面的事，所以一直在想着怎么把代码写好，怎么把一个项目维护好。</p><p>以前一两个人干活的时候，没有觉得有什么问题，一个项目托管在 <code>git</code>，各自 <code>fork</code> 仓库修改提交 <code>merge</code>。</p><p>并不需要什么规范化，因为两个人的代码风格都差不多，都遵循一些公认的规范，也就不需要强制要求什么。</p><p>然而人多的时候，确实会是麻烦事，到处代码风格不一致，<code>tab</code>、空格混合用，强迫症总是会很不爽的想改成一致。</p><p>以上，所以想要开始规范起代码，规范流程，像一个工程应该有的样子。</p><h3 id="什么是-EditorConfig"><a href="#什么是-EditorConfig" class="headerlink" title="什么是 EditorConfig"></a>什么是 EditorConfig</h3><blockquote><p>EditorConfig helps developers define and maintain consistent coding styles between different editors and IDEs.<br>The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles.<br>EditorConfig files are easily readable and they work nicely with version control systems.</p></blockquote><p>简单来说 <code>EditorConfig</code> 就是帮助开发者在不同的编辑器里统一代码格式的一套解决方案。</p><h3 id="EditorConfig-的配置文件是怎样的？"><a href="#EditorConfig-的配置文件是怎样的？" class="headerlink" title="EditorConfig 的配置文件是怎样的？"></a>EditorConfig 的配置文件是怎样的？</h3><p>以下例子，<code>.editorconfig</code> 用来定义 <code>Python</code> 和 <code>JavaScript</code> 的尾行和缩进风格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># EditorConfig is awesome: http://EditorConfig.org</div><div class="line"></div><div class="line"># top-most EditorConfig file</div><div class="line">root = true</div><div class="line"></div><div class="line"># Unix-style newlines with a newline ending every file</div><div class="line">[*]</div><div class="line">end_of_line = lf</div><div class="line">insert_final_newline = true</div><div class="line"></div><div class="line"># Matches multiple files with brace expansion notation</div><div class="line"># Set default charset</div><div class="line">[*.&#123;js,py&#125;]</div><div class="line">charset = utf-8</div><div class="line"></div><div class="line"># 4 space indentation</div><div class="line">[*.py]</div><div class="line">indent_style = space</div><div class="line">indent_size = 4</div><div class="line"></div><div class="line"># Tab indentation (no size specified)</div><div class="line">[Makefile]</div><div class="line">indent_style = tab</div><div class="line"></div><div class="line"># Indentation override for all JS under lib directory</div><div class="line">[lib/**.js]</div><div class="line">indent_style = space</div><div class="line">indent_size = 2</div><div class="line"></div><div class="line"># Matches the exact files either package.json or .travis.yml</div><div class="line">[&#123;package.json,.travis.yml&#125;]</div><div class="line">indent_style = space</div><div class="line">indent_size = 2</div></pre></td></tr></table></figure><p>更多示例 <a href="https://github.com/editorconfig/editorconfig/wiki/Projects-Using-EditorConfig">那些使用 EditorConfig 的项目</a></p><h3 id="在哪存放-EditorConfig-文件"><a href="#在哪存放-EditorConfig-文件" class="headerlink" title="在哪存放 EditorConfig 文件"></a>在哪存放 EditorConfig 文件</h3><p><code>EditorConfig</code> 插件会在打开文件的目录向上级目录查找 <code>.editorconfig</code> 文件，</p><p>直到有一个配置文件 <code>root=true</code>，所以配置一般会存放在项目根目录。</p><p><code>EditorConfig</code> 配置文件从上往下读取，并且路径最近的文件最后被读取，所以最接近代码文件的属性优先级最高。</p><p>当然，一般一个项目也就一个配置文件</p><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p><code>EditorConfig</code> 文件使用<a href="https://zh.wikipedia.org/wiki/INI%E6%96%87%E4%BB%B6" target="_blank" rel="external">INI格式</a>，为了可以与 <a href="https://docs.python.org/2/library/configparser.html" target="_blank" rel="external">Python ConfigParser Library</a> 兼容，<br>但是允许在 section names 中使用 ‘and’(不知道 section names 应该怎么翻译 )。<br>section names 是<a href="">全局</a><a href="https://en.wikipedia.org/wiki/Glob_(programming)文件路径，" target="_blank" rel="external">https://en.wikipedia.org/wiki/Glob_(programming)文件路径，</a><br>类似于 <a href="http://manpages.ubuntu.com/manpages/intrepid/man5/gitignore.5.html#contenttoc2" target="_blank" rel="external">gitignore</a>。</p><blockquote><p><code>/</code>: 路径分隔符<br><code>#</code> or <code>;</code> 注释，注释应该独占一行。</p></blockquote><p><code>EditorConfig</code> 文件使用 UTF-8 格式、CRLF 或 LF 作为换行符。</p><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配除(/)之外的任意字符串</td></tr><tr><td><code>**</code></td><td>匹配任意字符串</td></tr><tr><td><code>?</code></td><td>匹配任意单个字符</td></tr><tr><td><code>[name]</code></td><td>匹配 name 字符</td></tr><tr><td><code>[!name]</code></td><td>匹配任意除了 name 外的字符</td></tr><tr><td><code>{s1,s2,s3}</code></td><td>匹配任意给定的字符串 (version &gt;= 0.11.0)</td></tr></tbody></table><p>特殊字符使用 <code>\</code> 转义。</p><h4 id="支持的属性"><a href="#支持的属性" class="headerlink" title="支持的属性"></a>支持的属性</h4><p class="tip">并不是所有的属性都已经被编辑器插件支持了，具体查看 <a href="https://github.com/editorconfig/editorconfig/wiki/EditorConfig-Properties">wiki</a> </p><h3 id="编辑器支持情况"><a href="#编辑器支持情况" class="headerlink" title="编辑器支持情况"></a>编辑器支持情况</h3><p>具体查看官网 <a href="http://editorconfig.org/#download" target="_blank" rel="external">http://editorconfig.org/#download</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://editorconfig.org/" target="_blank" rel="external">EditorConfig</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础设施真的很重要，尤其是在经历了几个烂项目之后。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端工程" scheme="http://github.com/xwartz/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="EditorConfig" scheme="http://github.com/xwartz/tags/EditorConfig/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 浏览器的 source-map 功能</title>
    <link href="http://github.com/xwartz/2016/06/chrome-sourcemap/"/>
    <id>http://github.com/xwartz/2016/06/chrome-sourcemap/</id>
    <published>2016-06-16T13:22:49.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实已经很久没有使用 Chrome 的 source-map 功能了。</p><a id="more"></a><p><code>webpack</code> 非常火，它提供的 <code>HMR</code>(hot module replacement) 功能非常棒，修改代码无需刷新页面。那么在 <code>webpack</code> 出现之前，有什么好的方法呢。</p><p>作为前端开发，<code>Chrome</code> 应该是大家最喜欢的浏览器之一，调试代码非常方便。</p><p>这篇文章主要介绍下，<code>Chrome</code> 浏览器自带的 <code>source-map</code> 功能。</p><p>如果你的项目已经用 <code>webpack</code> 了，那就不太需要使用这个功能了，<code>webpack</code> 提供的 <code>HMR</code> 功能，开发起来很方便。</p><h3 id="添加文件夹到-Workspace"><a href="#添加文件夹到-Workspace" class="headerlink" title="添加文件夹到 Workspace"></a>添加文件夹到 Workspace</h3><p>右键选择 <code>Add Folder to Workspace</code></p><img src="/blog/2016/06/chrome-sourcemap/1.png" alt="1.png" title=""><p>并允许访问权限</p><h3 id="建立-Map"><a href="#建立-Map" class="headerlink" title="建立 Map"></a>建立 Map</h3><p>右键选择 <code>Map to Network Resource...</code>，选择对应的文件。</p><img src="/blog/2016/06/chrome-sourcemap/2.png" alt="2.png" title=""><p>如此便已有了 <code>source-map</code> 功能</p><p>只需要建立某个 <code>map</code> 的文件，<code>Chrome</code> 会为把整个目录下的文件都建立 <code>map</code> 关系。</p><h3 id="尝试修改"><a href="#尝试修改" class="headerlink" title="尝试修改"></a>尝试修改</h3><p>选择某个文件，修改代码，<code>cmd + s</code> 保存，然后你会发现编辑器里的代码也更新了。</p><p>或者，更新编辑器里的代码，<code>cmd + s</code> 保存，网页中的代码也相应的更新了。</p><p>当然它并没有 <code>webpack</code> 这样的 <code>HMR</code> 功能，如果想看到代码更新后的效果，还是需要刷新页面的。</p><h3 id="真正用途"><a href="#真正用途" class="headerlink" title="真正用途"></a>真正用途</h3><p>可能在对于 <code>js</code> 代码来说以上的 <code>map</code> 用处似乎并不大。</p><p>所以这个功能大多是在修改 <code>css</code> 代码的时候使用，</p><p>你可以直接看着页面，在控制台修改 <code>css</code> 代码就好了，都不需要去修改编辑器里的文件了。</p><p class="tip">Chrome 的这个功能还支持 <code>sass</code>，可以 <code>map</code> 到源代码，如果写 <code>sass</code> 的话，强力推荐。</p><p>其实你还可以在控制台删除，增加文件，参考 <a href="https://developer.chrome.com/devtools/docs/workspaces" target="_blank" rel="external">Workspaces - Persistent authoring in the DevTools</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实已经很久没有使用 Chrome 的 source-map 功能了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="devTools" scheme="http://github.com/xwartz/tags/devTools/"/>
    
  </entry>
  
  <entry>
    <title>webpack + karma + mocha + es6 编写单元测试</title>
    <link href="http://github.com/xwartz/2016/06/js-test-with-webpack-karma-mocha/"/>
    <id>http://github.com/xwartz/2016/06/js-test-with-webpack-karma-mocha/</id>
    <published>2016-06-14T15:58:00.000Z</published>
    <updated>2016-10-07T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>遥想当年在前公司，三个人的时候写单元测试，两个人的时候搞前后端分离，一个人的时候玩桌面应用。</p><a id="more"></a><img src="/blog/2016/06/js-test-with-webpack-karma-mocha/ill.png" alt="ill.png" title=""><h3 id="为什么写单元测试"><a href="#为什么写单元测试" class="headerlink" title="为什么写单元测试"></a>为什么写单元测试</h3><p>你问我支不支持写单元测试，我当然是支持的。尤其是在没有测试人员的时候，我可不想时不时搞出故障。</p><p>细想了下单元测试的好处：</p><blockquote><ul><li>能强迫你写出好的代码</li><li>能快速带新人入坑，填坑</li><li>在重构代码时，不用为发布线上担心</li><li>能在别人对着屏幕忙着测试时，挺着胸准时下班</li></ul></blockquote><p>编不下去了 ╮(╯_╰)╭ </p><h3 id="为什么选择-webpack"><a href="#为什么选择-webpack" class="headerlink" title="为什么选择 webpack"></a>为什么选择 <code>webpack</code></h3><p>当然是为了装逼啦，不然以后怎么对人家说 <code>webpack</code> 多简单啊，这你都能配置老半天! 看我（ˇ＾ˇ）</p><blockquote><ul><li>现在的开发多数项目使用了 <code>webpack</code></li><li>为了之后的可扩展，哪天想用 <code>react</code>，想换成 <code>vue</code>，想上 <code>es6</code> 啦</li></ul></blockquote><p>由以上两条，因为项目技术栈，可以共用配置，测试的 <code>webpack</code> 配置可以共用开发时的配置，<br>我可不想换个技术栈就得修改测试配置。</p><h3 id="为什么选择-karma"><a href="#为什么选择-karma" class="headerlink" title="为什么选择 karma"></a>为什么选择 <code>karma</code></h3><p>不多说，看官方推荐</p><blockquote><p>You want to test code in real browsers.<br>You want to test code in multiple browsers (desktop, mobile, tablets, etc.).<br>You want to execute your tests locally during development.<br>You want to execute your tests on a continuous integration server.<br>You want to execute your tests on every save.<br>You love your terminal.<br>You don’t want your (testing) life to suck.<br>You want to use Istanbul to automagically generate coverage reports.<br>You want to use RequireJS for your source files.</p></blockquote><h3 id="为什么选-mocha"><a href="#为什么选-mocha" class="headerlink" title="为什么选 mocha"></a>为什么选 <code>mocha</code></h3><p>只是因为以前写过，直接上手。</p><p>文档清晰，API 简单，扩展多。</p><p>至于其他可选的推荐 <code>jasmine</code>。</p><p>更多搭配 <a href="https://www.npmjs.org/browse/keyword/karma-adapter" target="_blank" rel="external">https://www.npmjs.org/browse/keyword/karma-adapter</a></p><h3 id="为什么用-es6"><a href="#为什么用-es6" class="headerlink" title="为什么用 es6"></a>为什么用 <code>es6</code></h3><p>既然都已经用 <code>webpack</code> 了，为什么不用 <code>es6</code> 呢？</p><p>现在不写写 <code>es6</code>，都要看不懂别人的源码咯。</p><h3 id="如何搭建"><a href="#如何搭建" class="headerlink" title="如何搭建"></a>如何搭建</h3><p>说起来是有挺多坑的 (～ o ～)Y</p><h4 id="webpack-config"><a href="#webpack-config" class="headerlink" title="webpack.config"></a>webpack.config</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">loaders</span>: [&#123;</div><div class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">      <span class="attr">loader</span>: <span class="string">'babel'</span>,</div><div class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></div><div class="line">    &#125;],</div><div class="line">    <span class="comment">// instrument only testing sources with Istanbul</span></div><div class="line">    postLoaders: [&#123;</div><div class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">      <span class="attr">exclude</span>: <span class="regexp">/test\/|node_modules/</span>,</div><div class="line">      <span class="attr">loaders</span>: [<span class="string">'istanbul-instrumenter'</span>]</div><div class="line">    &#125;]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">resolve</span>: &#123;</div><div class="line">    <span class="attr">alias</span>: &#123;</div><div class="line">      <span class="attr">utils</span>: path.join(__dirname, <span class="string">'src/utils'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里只有一个地方要注意下 <code>postLoaders</code></p><p>在 <code>webpack</code> 打包前需要经过 <code>istanbul-instrumenter-loader</code> 处理，覆盖率统计的应该是源码。</p><p><em>开发时也是用的 <code>webpack</code>，可以提取共用的部分。</em></p><h3 id="karma-config"><a href="#karma-config" class="headerlink" title="karma.config"></a>karma.config</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> webpackConfig <span class="keyword">from</span> <span class="string">'./webpack.config'</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line">  config.set(&#123;</div><div class="line">    <span class="comment">// 使用的测试框架</span></div><div class="line">    frameworks: [<span class="string">'mocha'</span>],</div><div class="line"></div><div class="line">    <span class="comment">// 测试文件</span></div><div class="line">    files: [</div><div class="line">      <span class="string">'test/**/*.js'</span></div><div class="line">    ],</div><div class="line"></div><div class="line">    <span class="comment">// 处理测试文件</span></div><div class="line">    preprocessors: &#123;</div><div class="line">      <span class="string">'test/**/*.js'</span>: [<span class="string">'webpack'</span>, <span class="string">'sourcemap'</span>]</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">// 测试日志格式</span></div><div class="line">    reporters: [<span class="string">'mocha'</span>, <span class="string">'coverage'</span>],</div><div class="line"></div><div class="line">    <span class="comment">// 不显示 `webpack` 打包日志信息</span></div><div class="line">    webpackServer: &#123;</div><div class="line">      <span class="attr">noInfo</span>: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">// karma 插件</span></div><div class="line">    plugins: [</div><div class="line">      <span class="string">'karma-coverage'</span>,</div><div class="line">      <span class="string">'karma-webpack'</span>,</div><div class="line">      <span class="string">'karma-mocha'</span>,</div><div class="line">      <span class="comment">// 'karma-chai',</span></div><div class="line">      <span class="string">'karma-phantomjs-launcher'</span>,</div><div class="line">      <span class="string">'karma-sourcemap-loader'</span>,</div><div class="line">      <span class="string">'karma-mocha-reporter'</span></div><div class="line">    ],</div><div class="line"></div><div class="line">    <span class="comment">// `webpack` 配置</span></div><div class="line">    webpack: webpackConfig,</div><div class="line"></div><div class="line">    <span class="comment">// karma 服务器的监听端口</span></div><div class="line">    port: <span class="number">9876</span>,</div><div class="line">    <span class="comment">// 输出日志为彩色</span></div><div class="line">    colors: <span class="literal">true</span>,</div><div class="line">    <span class="comment">// 自动监测测试文件内容</span></div><div class="line">    autoWatch: <span class="literal">false</span>,</div><div class="line">    <span class="comment">// 测试所用平台</span></div><div class="line">    browsers: [<span class="string">'PhantomJS'</span>],</div><div class="line">    <span class="comment">// 只运行一次</span></div><div class="line">    singleRun: <span class="literal">true</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 代码覆盖率日志</span></div><div class="line">    coverageReporter: &#123;</div><div class="line">      <span class="attr">reporters</span>: [</div><div class="line">        &#123; <span class="attr">type</span>: <span class="string">'lcov'</span>, <span class="attr">dir</span>: <span class="string">'coverage'</span>, <span class="attr">subdir</span>: <span class="string">'.'</span> &#125;,</div><div class="line">        &#123; <span class="attr">type</span>: <span class="string">'text-summary'</span>, <span class="attr">dir</span>: <span class="string">'coverage'</span>, <span class="attr">subdir</span>: <span class="string">'.'</span> &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里需要注意下 <code>preprocessors</code>，需要对编写的测试代码使用 <code>webpack</code> 预先处理。</p><p><code>coverage</code> 一定要在 <code>reporters</code> 产生日志时使用，</p><p>在这之前使用，会将 <code>webpack</code> 转化的代码也加入进去，影响测试覆盖率。</p><p>关于测试覆盖率不准确也可以查看这里的讨论 <a href="https://github.com/webpack/karma-webpack/issues/21">code coverage with karma-coverage</a>。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>以上代码都是用 <code>es6</code> 编写，包括配置文件，所以必须借助 <code>babel</code> 运行。</p><figure class="highlight json"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>babel</code> 配置，根据你项目技术栈修改。</p><p>运行 <code>karma</code>，借助 <code>babel-register</code>。</p><figure class="highlight"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">  "test": "node -r babel-register ./node_modules/.bin/karma start karma.config.js"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上，命令行执行 <code>npm run test</code>。</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>开源仓库推荐使用 <code>travis-ci</code></p><figure class="highlight yml"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="attr">sudo:</span> <span class="literal">false</span></div><div class="line"><span class="attr">language:</span> node_js</div><div class="line"><span class="attr">node_js:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">'node'</span></div><div class="line"></div><div class="line"><span class="attr">cache:</span></div><div class="line"><span class="attr">  directories:</span></div><div class="line"><span class="bullet">    -</span> node_modules</div><div class="line"></div><div class="line"><span class="attr">install:</span></div><div class="line"><span class="bullet">  -</span> npm install</div><div class="line"></div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">  -</span> npm run test</div><div class="line"></div><div class="line"><span class="attr">os:</span></div><div class="line"><span class="bullet">  -</span> osx</div></pre></td></tr></table></figure><p>私有仓库的话，可以使用 Jenkins(<a href="https://jenkins.io/" target="_blank" rel="external">https://jenkins.io/</a>) 自己搭建一个。</p><hr><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p>可参考 <a href="https://github.com/xwartz/webpack-karma-mocha">demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遥想当年在前公司，三个人的时候写单元测试，两个人的时候搞前后端分离，一个人的时候玩桌面应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端工程" scheme="http://github.com/xwartz/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="单元测试" scheme="http://github.com/xwartz/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
